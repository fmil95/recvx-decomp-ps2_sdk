<HTML>
<HEAD>
<TITLE> IOP Kernel API</TITLE>
<META HTTP-EQUIV=Content-Type CONTENT="text/html; charset=Shift_JIS">
</HEAD>
<BODY BGCOLOR=#ffffff TEXT=#000000 LINK=#0000ff ALINK=#ffff00 VLINK=#800080>
<TABLE WIDTH="100%">
<TR><TD>
<H4>"PlayStation 2" Programmer Tool Runtime Library Release 2.0</H4>
</TD><TD ALIGN="right">
<FORM><SELECT NAME=list onchange=location.href=this.form.list.options[this.form.list.selectedIndex].value><OPTION VALUE="iopkernl.htm" SELECTED> IOPカーネル
<OPTION VALUE="../../index.htm">TOP MENU
<OPTION VALUE="../../general/index.htm">EE/IOP共通文書
<OPTION VALUE="../../ee/overview/index.htm">EE Overview
<OPTION VALUE="../../ee/libref/index.htm">EE Library Reference
<OPTION VALUE="../../iop/overview/index.htm">IOP Overview
<OPTION VALUE="../../iop/libref/index.htm">IOP Library Reference
<OPTION VALUE="../../deci2/index.htm">DECI2
<OPTION VALUE="../../tool/index.htm">各種ツール
<OPTION VALUE="../../pdadoc/pda/index.htm">PDA関連
</SELECT>
</FORM>
</TD></TR></TABLE>
<HR NOSHADE SIZE=8>
<A NAME=Heading2>
<H1>
IOP Kernel API<BR>
</H1>
</A>
<DIV align=center>
<TABLE border=0 bgcolor=#D6E0BA width=90%><TR><TD>
<H2><U>
        <B>目次</B>
</U></H2>

<blockquote>
<UL>
<P><A HREF="#Heading3_1">  1 ライブラリ概要<BR></A>
    <UL>
    <A HREF="#Heading4_1_1"> 概要<BR></A><BR>
    <A HREF="#Heading4_1_2"> ソフトウェア階層<BR></A><BR>
    <A HREF="#Heading4_1_3"> 関連ファイル<BR></A><BR>
    </UL>
<P><A HREF="#Heading3_2">  2 マルチスレッド管理<BR></A>
    <UL>
    <A HREF="#Heading4_2_1"> スレッドの概要<BR></A><BR>
    <A HREF="#Heading4_2_2"> スレッドの状態と動作<BR></A><BR>
    <A HREF="#Heading4_2_3"> スレッドのスケジューリング<BR></A><BR>
    <A HREF="#Heading4_2_4"> スレッド間の同期<BR></A><BR>
    </UL>
<P><A HREF="#Heading3_3">  3 その他のサービス<BR></A>
    <UL>
    <A HREF="#Heading4_3_1"> メモリ割り当てサービスの概要<BR></A><BR>
    <A HREF="#Heading4_3_2"> モジュール管理の概要<BR></A><BR>
    <A HREF="#Heading4_3_3"> 割り込み管理の概要<BR></A><BR>
    <A HREF="#Heading4_3_4"> タイマ管理の概要<BR></A><BR>
    <A HREF="#Heading4_3_5"> Vblank管理の概要<BR></A><BR>
    </UL>
<P><A HREF="#Heading3_4">  4 注意事項<BR></A>
    <UL>
    <A HREF="#Heading4_4_1"> スレッド部とスレッド独立部<BR></A><BR>
    </UL>
</UL>
</blockquote>
</TD></TR></TABLE>
</DIV>
<DIV align=center>

<!-- 見出し 2,章見出し -->
<A NAME="Heading2">
</DIV>

<!-- 見出し 3,節見出し -->
<A NAME="Heading3_1">
<H2>
<A HREF="#Top"><IMG SRC = gif/link.gif BORDER = 0></A> 1 <B>ライブラリ概要</B>
<HR NOSHADE>
</H2>
</A>

<blockquote>
</blockquote>

<!-- 見出し 4,小見出し -->
<H3>
<A NAME="Heading4_1_1">
<A HREF="#Heading3_1"> 1. </A>1 <B>概要</B>
</A>
</H3>
<blockquote>
    IOP Kernelは、IOP上で動作するオペレーティングシステムです。優先度ベースのシンプルでリアルタイム処理に適したマルチスレッドスケジューリング機能を持ち、セマフォ / イベントフラグ / メッセージボックスによるスレッド間同期・通信、割り込みハンドラの管理、メモリプールの管理、タイマ管理、V-blank同期などの機能をシステムコールとして提供します。<BR>
    また、IOPプログラムはメモリ上でモジュールとして管理されますが、その管理とともに、モジュールの一部を他のモジュールにサブルーチンとして提供する「常駐ライブラリ」の機能をサポートします。<BR>
</blockquote>

<!-- 見出し 4,小見出し -->
<H3>
<A NAME="Heading4_1_2">
<A HREF="#Heading3_1"> 1. </A>2 <B>ソフトウェア階層</B>
</A>
</H3>
<blockquote>
    IOPのメモリ上に存在するソフトウェアは、以下の階層構造を持ちます。<BR>
    <BR>
<DIV align=center>
<P>
<IMG SRC ="gif/iopkn1.gif">
<P>
    <BR>
</DIV>

<!-- 見出し 5,(1) -->
<H4>
<A NAME="Heading5_1_2_1">
(1) <B>IOPサービスプログラム群</B>
</A>
</H4>
    IOPサービスプログラムは、下層に位置するさまざまなマネージャ、ドライバ、カーネルを呼び出して、IOPが果たすべきI/O processerとしての仕事を実現するプログラムです。<BR>
    IOPサービスプログラムは、EEとの通信をハンドリングするデバイスドライバからEEのリクエストを受け取り、そのリクエストに基づいたI/O動作を適切なI/Oデバイスドライバを呼び出して実行し、その結果をEEに返します。<BR>

<!-- 見出し 5,(1) -->
<H4>
<A NAME="Heading5_1_2_2">
(2) <B>システムメモリマネージャ</B>
</A>
</H4>
    システムメモリマネージャは、メモリ領域全体の管理を行い、上層のソフトウェアに対して次の機能を提供します。<BR>
    <OL TYPE="a">
         <LI VALUE= 1> 全メモリサイズの取得<BR>
         <LI VALUE= 2> メモリエリアの割り当て（メモリの先頭から割り付け）<BR>
         <LI VALUE= 3> メモリエリアの割り当て（メモリの末尾から割り付け）<BR>
         <LI VALUE= 4> メモリエリアの解放<BR>
    </OL>
    メモリの割り当ては256byte単位で行います。メモリの使用イメージは次のようになります。<BR>
    <BR>
<DIV align=center>
<P>
<IMG SRC ="gif/iopkn2.gif">
<P>
    <BR>
</DIV>
    標準では、システムメモリマネージャを直接呼び出してメモリを確保するのはマルチスレッドマネージャとプログラムローダだけで、デバイスドライバ以上の層のプログラムは、マルチスレッドマネージャの提供するメモリ割り当てサービスを利用します。<BR>

<!-- 見出し 5,(1) -->
<H4>
<A NAME="Heading5_1_2_3">
(3) <B>プログラムローダ</B>
</A>
</H4>
    プログラムローダは、CD-ROM / DVD-ROM / ROM等からプログラムモジュールをメモリにロードし、メモリ上のモジュールを管理します。下層にあたるモジュールマネージャと上層にあたるファイルローダで構成されています。<BR>
    モジュールマネージャは次の機能を持ちます。<BR>
<UL>
         <LI> メモリ上のプログラムモジュールの管理<BR>
         <LI> 常駐ライブラリの管理（ロード時のリンク処理を含む）<BR>
         <LI> リロケータブルモジュールのメモリ上への配置<BR>
</UL>
    ファイルローダは、モジュールマネージャとファイルシステムマネージャを呼び出して以下の機能を実現します。<BR>
<UL>
         <LI> プログラムモジュールファイルのロード<BR>
         <LI> プログラムモジュールファイルとメモリ上モジュールのバージョン比較、置き換え<BR>
</UL>

<!-- 見出し 5,(1) -->
<H4>
<A NAME="Heading5_1_2_4">
(4) <B>例外ハンドラマネージャ</B>
</A>
</H4>
    例外ハンドラマネージャは、CPUの各例外（INT,IBE,DBE,Sys,Bp...）ハンドラへのジャンプテーブルの管理ルーチンと、例外を判定して各ハンドラに制御を渡す統合例外ハンドラで構成されます。通常のアプリケーションから呼び出されることはなく、主にデバッグシステムとマルチスレッドマネージャから利用されます。<BR>

<!-- 見出し 5,(1) -->
<H4>
<A NAME="Heading5_1_2_5">
(5) <B>割り込みハンドラマネージャ</B>
</A>
</H4>
    割り込みハンドラマネージャは、割り込みハンドラの登録・管理ルーチンと、割り込み要因を判定して各ハンドラに制御を渡す統合割り込みハンドラで構成されます。IOPには20数本の割り込み要因があり、要因別のマスクレジスタとマスターマスクレジスタによって割り込み禁止 / 許可を設定することができ、これらのマスクを操作する関数が用意されています。割り込みが発生すると、割り込みハンドラマネージャは割り込みステータスレジスタとマスクレジスタを参照して割り込み要因を判定し、登録されている適切な割り込みハンドラを呼び出します.<BR>

<!-- 見出し 5,(1) -->
<H4>
<A NAME="Heading5_1_2_6">
(6) <B>マルチスレッドマネージャ</B>
</A>
</H4>
    CPU資源の管理とメモリ資源の管理、割り込み資源の管理を行い、上層のソフトウェアに対して次の機能を提供します。<BR>
    <OL TYPE="a">
         <LI VALUE= 1> スレッドの管理機能<BR>
         <LI VALUE= 2> スレッドのスケジューリング機能<BR>
         <LI VALUE= 3> スレッド間の同期機能<BR>
         <LI VALUE= 4> メモリ管理機能<BR>
         <LI VALUE= 5> 割り込み管理機能<BR>
    </OL>

<!-- 見出し 5,(1) -->
<H4>
<A NAME="Heading5_1_2_7">
(7) <B>デバイスドライバ群</B>
</A>
</H4>
    デバイスドライバは、マルチスレッドマネージャの機能を使用し、各I/Oデバイスをハンドリングするモジュールで、次の３つの部分で構成されます。<BR>
<UL>
         <LI> 割り込み処理ルーチン（必要があれば）<BR>
         <LI> デバイスコントロールスレッド（0個以上）<BR>
         <LI> エントリ関数群<BR>
</UL>
    エントリ関数群は、上層のプログラムから呼び出されて、I/Oリクエストをデバイスコントロールスレッドに渡すかまたは直接デバイスをコントロールする処理を行います。エントリ関数群自体は、呼び出し側スレッドのコンテキストで実行されます。<BR>

<!-- 見出し 5,(1) -->
<H4>
<A NAME="Heading5_1_2_8">
(8) <B>ファイルシステムマネージャ</B>
</A>
</H4>
    ファイルシステムマネージャは、open(), close(), read(), write()などデバイスに依存しないファイルアクセスAPIを提供し、デバイスドライバが持つこれらのエントリ群の登録管理を行います。<BR>
</blockquote>

<!-- 見出し 4,小見出し -->
<H3>
<A NAME="Heading4_1_3">
<A HREF="#Heading3_1"> 1. </A>3 <B>関連ファイル</B>
</A>
</H3>
<blockquote>
    IOP Kernel APIを利用するのに必要なファイルは次のとおりです。<BR>
    <BR>
<TABLE BORDER>
<TR>
<TD valign="TOP" bgcolor="#cccccc"><B>カテゴリ</B></TD>
<TD valign="TOP" bgcolor="#cccccc"><B>ファイル名</B></TD>
</TR>
<TR>
<TD valign="TOP">ヘッダファイル</TD>
<TD valign="TOP">kernel.h</TD>
</TR>
</TABLE>
<BR>
    <BR>
</blockquote>

<!-- 見出し 3,節見出し -->
<A NAME="Heading3_2">
<H2>
<A HREF="#Top"><IMG SRC = gif/link.gif BORDER = 0></A> 2 <B>マルチスレッド管理</B>
<HR NOSHADE>
</H2>
</A>

<blockquote>
</blockquote>

<!-- 見出し 4,小見出し -->
<H3>
<A NAME="Heading4_2_1">
<A HREF="#Heading3_2"> 2. </A>1 <B>スレッドの概要</B>
</A>
</H3>
<blockquote>
    スレッドとは、並行処理の観点から見た、プログラムの論理的な単位です。アプリケーションプログラムの処理内容を複数のスレッドに分け、それらを同時並行的に動作させることができます。同時並行といってもCPUはひとつしかありませんから、ある短い時間内で見ると、実行されているスレッドはひとつだけです。どのスレッドが実行されるかは、各スレッドの状態と優先度によって決められます。優先度の高いスレッドが実行中であればそのスレッドが待ち状態に入るか割り込みハンドラ中で状態が変更されない限り、それより優先度の低いスレッドが実行されることはありません。複数のタスク（またはプロセス）を切り替えながらまんべんなく実行しようとするTSS（Time Sharing System）とはこの点で大きく異なっています。<BR>
    入出力装置やメモリ上の特定のワークエリアなどの資源は、スレッド間で排他的に使用するように調整しなければなりません。IOP Kernelはスレッド間の同期・通信機能として、セマフォ／イベントフラグ／メッセージボックスを提供しています。<BR>
    なお、スレッドと割り込みハンドラは明確に区別されます。スレッドはあくまでユーザプログラムの一部として、割り込みハンドラはカーネルの一部として、それぞれ異なるシステム状態のもとで実行されます。これに関連して、プログラムを記述するうえでいくつか注意すべき点があります。<BR>
</blockquote>

<!-- 見出し 4,小見出し -->
<H3>
<A NAME="Heading4_2_2">
<A HREF="#Heading3_2"> 2. </A>2 <B>スレッドの状態と動作</B>
</A>
</H3>
<blockquote>
    IOP Kernelの管理するスレッドは、以下の7つ（大きく見ると５つ）の状態をもちます。<BR>
    <BR>
<TABLE BORDER>
<TR>
<TD valign="TOP" bgcolor="#cccccc"><B>状態</B></TD>
<TD valign="TOP" bgcolor="#cccccc"><B>説明</B></TD>
</TR>
<TR>
<TD valign="TOP">RUN</TD>
<TD valign="TOP">実行状態。CPUがそのスレッドを実行中の状態</TD>
</TR>
<TR>
<TD valign="TOP">READY</TD>
<TD valign="TOP">実行可能な状態。CPUが他のスレッドを実行中であるため<BR>待機している状態</TD>
</TR>
<TR>
<TD valign="TOP">WAIT</TD>
<TD valign="TOP">待ち状態。ある条件が成立するまで、自ら待ちに入った状態</TD>
</TR>
<TR>
<TD valign="TOP">SUSPEND</TD>
<TD valign="TOP">強制待ち状態。他のスレッドが発行したシステムコールに<BR>よって強制的に待ちに入れられた状態</TD>
</TR>
<TR>
<TD valign="TOP">WAIT-SUSPEND</TD>
<TD valign="TOP">2重待ち状態。WAIT状態であったときに他のスレッドから<BR>強制的に待ちに入れられた状態</TD>
</TR>
<TR>
<TD valign="TOP">DORMANT</TD>
<TD valign="TOP">休止状態。スレッドが生成されてまだ起動されていない状態<BR>、または終了してから削除されるまでの状態</TD>
</TR>
<TR>
<TD valign="TOP">NON-EXSITENT</TD>
<TD valign="TOP">未登録状態。スレッドが生成されていない、または削除され<BR>た後の仮想的な状態</TD>
</TR>
</TABLE>
<BR>
    <BR>
<UL>
         <LI> RUN：実行状態<BR>CPUがそのスレッドを実行中であるという状態です。ある瞬間について見れば、この状態のスレッドはひとつしかありません。<BR>
         <LI> READY：実行可能状態<BR>そのスレッドは実行できる条件が整っているが、より優先度の高い（あるいは同じ）スレッドが実行中であるために待機している状態です。READY状態のスレッドが複数個ある場合、それらのスレッドはCPUが空くのを待って待ち行列を作ります。これをレディキューと呼びます。<BR>
         <LI> WAIT：待ち状態／SUSPEND：強制待ち状態／WAIT-SUSPEND：2重待ち状態<BR>そのスレッドが実行できる条件が整わないため実行を止められている、実行保留状態です。WAITは自スレッドの発行したシステムコールによって実行が止まっている状態、SUSPENDは他のスレッドから強制的に止められている状態、WAIT-SUSPENDはWAIT中にさらに他スレッドによって止められた状態です。<BR>待ち状態からの実行再開は、実行を中断した場所から行われ、プログラムカウンタやレジスタなどプログラムの実行状態を表現する情報（コンテキスト）はそのまま復元されます。<BR>
         <LI> DORMANT：休止状態<BR>スレッドがまだ起動されていない状態、または終了した状態。スレッドを生成するとまずこの状態になります。<BR>
         <LI> NON-EXISTENT：未登録状態<BR>スレッドが作成される前、または削除されたあとの、仮想的な状態です。<BR>
<P>
<IMG SRC ="gif/iopkn3.gif">
<P>
</UL>
    <BR>
    生成されたスレッドはまずDORMANT状態になり、起動されることによってREADY状態となってレディキュー（詳細後述）に入り、レディキューの先頭にあるスレッドが実行されてRUN状態となります。RUN状態のスレッドは、スリープするかまたはセマフォなどの条件を待つことによってWAIT状態に移り、待ち条件が成立するとREADY状態に戻ります。<BR>
</blockquote>

<!-- 見出し 4,小見出し -->
<H3>
<A NAME="Heading4_2_3">
<A HREF="#Heading3_2"> 2. </A>3 <B>スレッドのスケジューリング</B>
</A>
</H3>
<blockquote>
    READY状態にある複数のスレッドをどのような順序で実行する（RUN状態に移す）か、その調整・制御をスケジューリングと呼びます。IOP Kernelでのスケジューリングについて以下説明します。<BR>

<!-- 見出し 5,(1) -->
<H4>
<A NAME="Heading5_2_3_1">
(1) <B>優先度</B>
</A>
</H4>
    スレッドはそれぞれ優先度を持ち、READY状態のスレッドはそれぞれの持つ優先度にしたがってスケジューリングされ実行されます。実行されているスレッドが同一優先度以下のスレッドにCPUを奪われる（RUN状態からはずされる）ことは、基本的にはありません。優先度の範囲は1〜126で、数値の小さいほうが高い優先度を表します。一部の優先度はシステムで予約されていて、ユーザプログラムで使用できる優先度の範囲はUSER_HIGHEST_PRIORITY（=9） 〜 USER_LOWEST_PRIORITY（=123）に限られています。<BR>

<!-- 見出し 5,(1) -->
<H4>
<A NAME="Heading5_2_3_2">
(2) <B>レディキュー</B>
</A>
</H4>
    RUN状態およびREADY状態のスレッドを、実行される優先順位にしたがって並べたものがレディキューです。レディキューの並び順は各スレッドが持つ優先度の高い順で、同一優先度のスレッドどうしは早くREADY状態になった順に並びます。<BR>
    たとえば次のように、優先度11のスレッドA、優先度12のスレッドB、C、D、優先度13のスレッドE、Fがレディキューに存在するとします。<BR>
    <BR>
<P>
<IMG SRC ="gif/iopkn4.gif">
<P>
    <BR>
    レディキューにあるもっとも優先度の高いスレッドはスレッドAなので、スレッドAが実行されます。スレッドAの実行中、暗黙のうちに他のスレッドに実行が移ることはありません。スレッドAがWAIT状態になると、レディキューは下図のようになり、スレッドBが実行されます。<BR>
    <BR>
<P>
<IMG SRC ="gif/iopkn5.gif">
<P>
    <BR>
    実際のプログラミングにおいては、各スレッドは処理が一段落したり外部の処理を待たねばならなくなったところでWAIT状態に移るようにしておきます。<BR>

<!-- 見出し 5,(1) -->
<H4>
<A NAME="Heading5_2_3_3">
(3) <B>割り込みとスケジューリング</B>
</A>
</H4>
    割り込みが発生すると（割り込み禁止状態でなければ）割り込みハンドラに制御が移り、割り込みハンドラからリターンする時点で、各スレッドの状態と優先度にしたがって再度スケジューリングが行われます。<BR>
    割り込みハンドラ内でスレッドAをREADY状態に移したりスレッドBの優先度を下げたりする処理が行われない限り、割り込みハンドラから戻ったあともやはりスレッドBが実行されます。割り込みハンドラ内でスレッドAがREADY状態に移されると、リターン時の再スケジューリングでスレッドAがRUN状態になり、スレッドBはRUN状態からREADY状態に移ります（スレッドBがプリエンプトされた、といいます）。この場合でもレディキュー内のスレッドBの位置は変わらないので、スレッドAがレディキューから外れれば再びスレッドBが実行されます。<BR>
    <BR>
<P>
<IMG SRC ="gif/iopkn6.gif">
<P>
    <BR>
    実際のプログラミングにおいては、割り込み発生時に行うべき処理をWAIT状態のスレッドとして待機させておき、割り込みハンドラ内でそのスレッドをREADY状態に移してリターンする、といった処理が一般的です。<BR>

<!-- 見出し 5,(1) -->
<H4>
<A NAME="Heading5_2_3_4">
(4) <B>優先度の変更</B>
</A>
</H4>
    スレッドの優先度は、ChangeThreadPriority()を用いて変更することができます。自分自身の優先度を変更することもできますし、他のスレッドの優先度を変更することもできます。また、レディキューを回転させるRotateThreadReadyQueue()を用いて、優先度の同じスレッドどうしの実行順序を変更することができます。たとえば優先度12をRotateReadyQueue()によって回転すると、先頭のスレッドが最後尾に移ってC,D,Bの順となります。<BR>
    またスレッド独立部（割り込みハンドラ内）では、iChangeThreadPriority()を用いてスレッドの優先度を変更したり、iRotateThreadReadyQueue()を用いてレディキューを回転させることができます。<BR>
    なお、待ち状態のスレッドがREADY状態に移った場合は、そのスレッドは該当優先度のレディキューの最後尾につきます。<BR>
</blockquote>

<!-- 見出し 4,小見出し -->
<H3>
<A NAME="Heading4_2_4">
<A HREF="#Heading3_2"> 2. </A>4 <B>スレッド間の同期</B>
</A>
</H3>
<blockquote>
    スレッドどうしの間で、入出力デバイスへのアクセス競合などを避けたり、同期して処理を行うために、IOP Kernelはいくつかの同期機能を提供しています。<BR>

<!-- 見出し 5,(1) -->
<H4>
<A NAME="Heading5_2_4_1">
(1) <B>スレッドのスリープ・起床</B>
</A>
</H4>
      <BLOCKQUOTE>
      各スレッドは、処理が一段落したり外部デバイスの処理を待たねばならなくなるなど、CPUを当面必要としなくなった時点でSleepThread()を呼び出し、WAIT状態に移ることができます。これを「スリープする」といいます。<BR>
      スリープしているスレッドは、他のスレッドまたはスレッド独立部からWakeupThread() / iWakeupThread()を用いてREADY状態に戻すことができます。これを、「スレッドを起床する」といいます。<BR>
      </BLOCKQUOTE>

<!-- 見出し 5,(1) -->
<H4>
<A NAME="Heading5_2_4_2">
(2) <B>イベントフラグ</B>
</A>
</H4>
      <BLOCKQUOTE>
      イベントフラグはより柔軟な同期処理を行うことができます。一時に多数のスレッドを起床するプログラムなどで有用です。<BR>
      まず、フラグの初期値を設定してイベントフラグを作成しておきます。条件の成立を待つスレッドはWaitEventFlag()を呼び出して、解除条件を指定してWAIT状態に移ります。他のスレッドまたは割り込みハンドラがSetEventFlag() / iSetEventFlag()によってフラグ値を変更すると、イベントフラグを待っているスレッドのうち、新しいフラグ値が解除条件に合致するものがREADY状態に戻ります。<BR>
      </BLOCKQUOTE>

<!-- 見出し 5,(1) -->
<H4>
<A NAME="Heading5_2_4_3">
(3) <B>セマフォ</B>
</A>
</H4>
      <BLOCKQUOTE>
      複数のスレッドが同じデバイスやバッファ領域などを使用する場合に、使用状況を他のスレッドに知らせて同期を取るために用意されているのがセマフォ（信号機）機能です。<BR>
      デバイス等を使用したいスレッドはWaitSema()を実行してセマフォ資源を取得し、つまり使用中フラグを立てることで使用権を取得してから使用します。使い終われば、SignalSema()を実行してセマフォ資源をシステムに返却します。<BR>
<DIV align=center>
<P>
<IMG SRC ="gif/iopkn7.gif">
<P>
      </BLOCKQUOTE>
    <BR>
</DIV>
      <BLOCKQUOTE>
      WaitSema()を実行したときにもし他のスレッドがデバイス等を使用中であれば、セマフォ資源は取得できず、そのスレッドはWAIT状態になってセマフォ待ち行列に入ります。デバイス等を使い終わったスレッドがSignalSema()を実行してセマフォ資源をシステムに返却すると、返却されたセマフォ資源がセマフォ待ち行列の先頭のスレッドに与えられ、そのスレッドはREADY状態に戻り、優先度によるスケジューリングにしたがって実行され、デバイス等を使用できるようになります。<BR>
<DIV align=center>
<P>
<IMG SRC ="gif/iopkn8.gif">
<P>
      </BLOCKQUOTE>
    <BR>
</DIV>
      <BLOCKQUOTE>
      セマフォ資源の個数はセマフォ作成時に指定することができるため、上記のような排他制御のほかに、複数のスレッドがデータを供給する共有バッファの有効データ数を表すような使いかたも可能です。データ供給側のスレッドは、共有バッファにデータを格納したときにSignalSema()を実行して有効データが増えたことを示します。それに対してデータ消費側のスレッドは、共有バッファからデータを取り出そうとするときにWaitSema()を実行して、セマフォ資源が取得できれば共有バッファ中のデータを処理し、取得できなければWAIT状態になってデータが供給されるのを待つことになります。<BR>
      </BLOCKQUOTE>

<!-- 見出し 5,(1) -->
<H4>
<A NAME="Heading5_2_4_4">
(4) <B>メッセージボックス</B>
</A>
</H4>
      <BLOCKQUOTE>
      メッセージボックスはスレッド間でのデータ交換をサポートするサービスで、セマフォとリングバッファの組み合わされたものと考えることもできます。<BR>
      まずCreateMbx()を用いてメッセージボックスを作成しておきます（複数可）。メッセージを待つスレッドはメッセージボックスの番号を指定してReceiveMbx()を発行してWAIT状態に入ります。他のスレッドまたはスレッド独立部からSendMbx() / iSendMbx()でメッセージボックスの番号を指定してメッセージを送信すると、そのメッセージボックスで待っているスレッドがREADY状態に移されます。<BR>
      <BR>
      </BLOCKQUOTE>
</blockquote>

<!-- 見出し 3,節見出し -->
<A NAME="Heading3_3">
<H2>
<A HREF="#Top"><IMG SRC = gif/link.gif BORDER = 0></A> 3 <B>その他のサービス</B>
<HR NOSHADE>
</H2>
</A>

<blockquote>
</blockquote>

<!-- 見出し 4,小見出し -->
<H3>
<A NAME="Heading4_3_1">
<A HREF="#Heading3_3"> 3. </A>1 <B>メモリ割り当てサービスの概要</B>
</A>
</H3>
<blockquote>
    マルチスレッドマネージャは、メモリ領域をヒープとして管理し、アプリケーションプログラムからの要求に応じてメモリブロックを割り当てるサービスを提供しています。<BR>
    ヒープの形式として、メモリブロックのサイズが固定されているヒープと、割り当てのたびにブロックサイズを指定できるヒープの2形式があります。また、空き領域がなく割り当てができないときには空き領域ができるまで待つ（WAIT状態になる）ものと、エラーとしてリターンするものと、2種類のAPIが用意されています。<BR>
</blockquote>

<!-- 見出し 4,小見出し -->
<H3>
<A NAME="Heading4_3_2">
<A HREF="#Heading3_3"> 3. </A>2 <B>モジュール管理の概要</B>
</A>
</H3>
<blockquote>
    IOPのメモリ上にロードされた個々のプログラムをモジュールと呼びます。モジュールはROMあるいはCD/DVD-ROMに格納されたリロケータブルオブジェクトファイル（IRXファイル）と１対１に対応します。<BR>

<!-- 見出し 5,(1) -->
<H4>
<A NAME="Heading5_3_2_1">
(1) <B>モジュールの構造</B>
</A>
</H4>
    モジュールは次の3つのセグメントで構成されます。<BR>
    <OL>
         <LI VALUE= 1> TEXT segment：プログラムコード、エントリテーブル構造体（後述）、呼び出しテーブル構造体（後述）<BR>
         <LI VALUE= 2> DATA segment：初期値付きデータ<BR>
         <LI VALUE= 3> BSS segment：初期値なしデータエリア<BR>
    </OL>
    DATA segmentとBSS segmentは無い場合もあります。各セグメントのサイズは16byteの整数倍で、上記の順序でメモリアドレスの小さいほうから連続して配置されます。<BR>
    モジュールにはそれぞれモジュール名とバージョンを持たせることができます。バージョンはメジャーバージョンとマイナーバージョンと、それぞれ1〜255の範囲で付けることができます。<BR>
    モジュールは以下の形式の起動エントリを持たねばなりません。起動エントリはモジュールがロードされたときに呼び出され、その返り値に応じて常駐処理が行われます。<BR>
<PRE>        int startentry( int argc, char *argv[] );
</PRE>
    起動エントリは起動エントリ専用のスレッドで実行されます。優先度は8で、スタックは2KBが用意されています。起動エントリに渡されるパラメータは、LoadStartModule()で指定されたargsおよびargpを、一般的なC言語のmain関数の引数と同じポインタ配列形式にスタック上で並べ替えたものとなります。<BR>

<!-- 見出し 5,(1) -->
<H4>
<A NAME="Heading5_3_2_2">
(2) <B>常駐ライブラリ</B>
</A>
</H4>
    モジュールのプログラムコードの一部を、他のモジュールからサブルーチンとして呼び出せるライブラリとしてシステムに登録することができます。このように、他のモジュールに対してサブルーチンを提供するモジュールを特に常駐ライブラリと呼びます。<BR>
    常駐ライブラリは、他モジュールに提供するサブルーチンのエントリアドレスをまとめたエントリテーブル構造体を持ち、起動時にRegisterLibraryEntries()を用いてシステムに登録します。一方、常駐ライブラリのサブルーチンを利用したいモジュールは、利用したいサブルーチンのインデックスをまとめた呼び出しテーブル構造体を持ちます。そのモジュールがロードされるときに、呼び出しテーブルが登録済みのライブラリと照合され、該当するサブルーチンのエントリアドレスに書き換えられます。<BR>
    <BR>
<P>
<IMG SRC ="gif/iopkn9.gif">
<P>
    <BR>
</blockquote>

<!-- 見出し 4,小見出し -->
<H3>
<A NAME="Heading4_3_3">
<A HREF="#Heading3_3"> 3. </A>3 <B>割り込み管理の概要</B>
</A>
</H3>
<blockquote>
    割り込みコントローラやDMA割り込み等の割り込み要因解析は、割り込みハンドラマネージャが行います。要因ごとに複数の割り込みハンドラを登録する機能があり、割り込みハンドラ内から、スレッドの起床やイベントフラグの設定などを行ってスレッドをコントロールすることができます。<BR>
</blockquote>

<!-- 見出し 4,小見出し -->
<H3>
<A NAME="Heading4_3_4">
<A HREF="#Heading3_3"> 3. </A>4 <B>タイマ管理の概要</B>
</A>
</H3>
<blockquote>
    IOPの持つハードウェアタイマの制御機能に加えて、指定した時間だけ自スレッドを停止する機能、指定した時間が経過した時点で特定の関数（アラームハンドラ）を呼び出すアラーム機能が用意されています。時間はマイクロ秒またはシステムクロック単位で指定しますが、実装上、100〜200マイクロ秒程度切り上げて（遅らされて）実行される場合があります。<BR>
</blockquote>

<!-- 見出し 4,小見出し -->
<H3>
<A NAME="Heading4_3_5">
<A HREF="#Heading3_3"> 3. </A>5 <B>Vblank管理の概要</B>
</A>
</H3>
<blockquote>
    V-blankと同期する処理をサポートするために、V-blank期間の開始 / 終了まで自スレッドを停止するAPIが用意されています。また、V-blank期間の開始または終了時に特定の関数（Vblankハンドラ）を呼び出す機能が用意されています。<BR>
</blockquote>

<!-- 見出し 3,節見出し -->
<A NAME="Heading3_4">
<H2>
<A HREF="#Top"><IMG SRC = gif/link.gif BORDER = 0></A> 4 <B>注意事項</B>
<HR NOSHADE>
</H2>
</A>

<blockquote>
</blockquote>

<!-- 見出し 4,小見出し -->
<H3>
<A NAME="Heading4_4_1">
<A HREF="#Heading3_4"> 4. </A>1 <B>スレッド部とスレッド独立部</B>
</A>
</H3>
<blockquote>
    マルチスレッドマネージャの環境下では、スレッド部を実行中のシステム状態とそれ以外の部分を実行中のシステム状態は異なっています。スレッド以外の部分、つまり割り込みハンドラを作成する際には、システム状態の違いを意識してプログラミングする必要があります。<BR>
    割り込みハンドラやタイマハンドラなどのスレッド独立部では、スレッド独立部に入る直前に実行中だったスレッドを特定することが無意味で「自スレッド」の概念が存在しません。また、実行中のスレッドを特定できないのでスレッドのディスパッチングは起きません。ディスパッチングが必要になっても、それはスレッド独立部を抜けるまで遅らされます（これを遅延ディスパッチ状態と呼びます）。<BR>
    スレッド独立部からは、待ち状態にはいるサービスコールや暗黙で自スレッドを指定するサービスコールを発行することは原理的に不可能です。また、マルチスレッドマネージャの実装上の都合で、同じ機能であってもスレッド部から発行するサービスコールとは内部処理が異なる場合があります。そこで、スレッド独立部から発行できるサービスコールは、スレッド部から発行するサービスコールとは異なるエントリ名で用意されています。すなわち、名前の先頭に'i'（英小文字）の付くサービスコールだけがスレッド独立部から発行することができます。たとえば、スレッドを起床するサービスコールWakeupThread()は、スレッド独立部から発行する場合は、iWakeupThread()として発行します。不適切なシステム状態のもとで発行されたサービスコールはエラーを返します。<BR>
</blockquote>
<A HREF="#Top"><IMG SRC = gif/link.gif BORDER = 0></A>
<HR>
<DIV ALIGN="right">
    Copyright (c) 2000 Sony Computer Entertainment Inc.  All Rights Reserved.<BR>
    SCEI CONFIDENTIAL
</DIV>
</BODY>
</HTML>
