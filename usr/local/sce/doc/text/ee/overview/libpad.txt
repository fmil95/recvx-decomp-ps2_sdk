[SCEI CONFIDENTIAL DOCUMENT]
"PlayStation 2" Programmer Tool Runtime Library Release 2.0
                  Copyright (C) 2000 by Sony Computer Entertainment Inc.
                                                     All Rights Reserved

コントローラライブラリ
=======================


 1 ライブラリ概要
------------------


  1.1 概要

    libpadは、EE上で利用するコントローラ制御ライブラリで、主な機能は次の
    とおりです。
         (1) ボタンデータの取得
         (2) コントローラモードの変更
         (3) アクチュエータの操作（振動）
    マルチタップライブラリ（libmtap）と併用することにより、マルチタップを
    介して接続されたコントローラを制御することができます。
    現在のバージョンでは、"PlayStation 2" / PlayStation用コントローラのう
    ち、以下のものに対応しています。
         (1) デジタルコントローラ（ID=4）
         (2) DUALSHOCK,アナログコントローラ(DUALSHOCK 2)（ID=7）
         (3) ネジコン（ID=2）
         (4) アナログジョイスティック（ID=5）
         (5) ナムコ製ガンコントローラ（ID=6）
         (6) ジョグコン,釣りコン（拡張ID）
    対応コントローラは順次追加され、将来的にはほぼすべての"PlayStation 2"
     / PlayStation用コントローラに対応する予定です。

  1.2 関連ファイル

    libpadを使用するために必要なファイルは次のとおりです。
    
    +---------------------+----------------------------------+
    |カテゴリ              ファイル名                        |
    +                     +                                  +
    |ライブラリファイル    libpad.a                          |
    |ヘッダファイル        libpad.h                          |
    |IOPモジュールファイル sio2man.irx                       |
    |                      padman.irx                        |
    |                      mtapman.irx（マルチタップ使用時） |
    +---------------------+----------------------------------+
    
    IOPモジュールは、EE側プログラムの起動時にsceSifLoadModule()を用いてロ
    ードしてください。
    また、リンクするライブラリを指定するため、各Makefile中でリンクオプシ
    ョンに「-lpad」を追加してください。

  1.3 サンプルプログラム

    libpadのサンプルプログラムとして以下のものがありますので、適宜参照し
    てください。

   (1) sce/ee/sample/pad/basic

      コントローラライブラリの基本的な使用例。

   (2) sce/ee/sample/pad/dual2

      アナログコントローラ(DUALSHOCK 2)の感圧機能を利用したサンプル。

   (3) sce/ee/sample/pad/mtap

      マルチタップライブラリを併用し、マルチタップに接続された最大４つの
      コントローラと通信を行うサンプル。

   (4) sce/ee/sample/pad/gun

      ガンコントローラを使用したサンプル。

 2 使用手順
------------


  2.1 基本的な使用手順

    libpadを使用してコントローラを操作する基本的な手順は次のとおりです。

   (1) IOPモジュールのロード

      sceSifLoadModule()を使用して、sio2man.irxをロード後、padman.irxをロ
      ードします。

   (2) ライブラリの初期化

      scePadInit()を呼び出して、コントローラライブラリを初期化します。

   (3) コントローラポートのオープン

      scePadPortOpen()を呼び出して、使用するコントローラポートを宣言しま
      す。パラメータにはポート番号、スロット番号（通常は0）と作業用バッフ
      ァへのポインタを指定します。
      作業用バッファはIOPからのDMA転送に使われる領域で、キャッシュの関係
      上64バイトアラインメントで確保しておく必要があります。

   (4) ボタン情報取得

      コントローラポートをオープンすると、ライブラリは自動的にコントロー
      ラとの通信を開始します。コントローラが通常状態になれば、scePadRead()
      を使用してコントローラのボタン情報を取得することができます。コント
      ローラが通常状態かどうかを調べるにはscePadGetState()を使用します。

   (5) 終了処理

      コントローラとの通信が不要となった場合はscePadPortClose()を呼び出し
      てすべてのコントローラポートをクローズし、scePadEnd()を呼び出します。

  2.2 ポート / スロット

    libpadの多くの関数には、通信対象のコントローラを指定するためにportと
    slotの2つの引数が設けられています。portは"PlayStation 2"本体のコント
    ローラ端子を、slotはマルチタップのコントローラ端子を指定するための引
    数です。本体に直接接続されたコントローラを操作するときは、portに適切
    なポート番号を指定し、slotには0を指定します。マルチタップを介して接続
    されたコントローラを操作するときは、portとslotをそれぞれ適切に指定し
    ます。次の図は、本体のコントローラ端子2にマルチタップが接続されている
    場合のポート番号・スロット番号を示します。
    
    

  2.3 サンプルソースコード

        main()
        {
            unsigned char rdata[32];
            u_long128 pad_dma_buff[scePadDmaBufferMax] 
        __attribute__((aligned(64)));
        
            scePadInit();
            scePadPortOpen(0, 0, pad_dma_buff);
            while(1) {
                scePadRead(0,0,rdata);
                .
                .
                .
            }
            scePadPortClose(0,0);
            scePadEnd();
        }

  2.4 マルチタップの使用手順

    "PlayStation 2"用マルチタップを使用する場合はマルチタップライブラリ（
    libmtap）を併用する必要があります。手順の詳細はマルチタップライブラリ
    のドキュメントを参照してください。
    マルチタップを使用する場合は、libpadの多くの関数に用意されている引数
    slotを使用します。マルチタップライブラリを適切に初期化することにより、
    引数slotでスロット番号を指定して、マルチタップに接続されたコントロー
    ラを扱うことができるようになります。

  2.5 アナログコントローラ(DUALSHOCK 2)感圧モードの使用手順

    アナログコントローラ(DUALSHOCK 2)は、アナログコントローラ(DUALSHOCK)
    に感圧機能が加えられたコントローラです。アナログコントローラ
    (DUALSHOCK 2)の感圧機能を使用するには、以下の手順により感圧モードに移
    行する必要があります。
         (1) scePadSetMainMode()でアナログモードに移行する。
         (2) scePadInfoPressMode()を呼び出し、コントローラがアナログコント
             ローラ(DUALSHOCK 2)であることを確認する
         (3) scePadEnterPressMode()を呼び出して感圧モードに移行する
    感圧モードではコントローラのボタン情報に感圧レベルのデータが追加され
    ます。追加される感圧レベルデータ以外はアナログコントローラ(DUALSHOCK)
    と同等で、コントローラモードIDは0x79に変わります。
    感圧レベルはボタンごとに8ビットの値で表され、強く押されるほど数値が大
    きくなります。0は押されていない状態ですので、押された強さは１から255
    までの255段階です。
    感圧モードから抜けるにはscePadExitPressMode()を使用します。
    感圧モード時にコントローラのANALOGモードスイッチが押された場合、（ロ
    ックしていなければ）デジタルモードに移行します。もう一度ANALOGモード
    スイッチが押されたときには、感圧モードではなくDUALSHOCKのアナログモー
    ドになりますので注意してください。感圧モードに移行するには再度
    scePadEnterPressMode()を呼び出す必要があります。

  2.6 アクチュエータ操作の手順

         (1) scePadSetActAlign()でalgin情報を設定する。
         (2) scePadSetActDirect()で、振動値をコントローラに送信する。
        振動値と回転数の関係は、以下のとおりです。
        
    +--------+----------------------------------+
    |小モータ 0 = 停止, 1 = 回転                |
    +        +                                  +
    |大モータ 0〜255  数値が大きいほど回転が速い|
    +--------+----------------------------------+
    

  2.7 スレッドプライオリティの変更手順

    padmanが使用するスレッドプライオリティはHighとLowの2種類があります。
    デフォルト値は High = 20, Low = 46 となっています。
    
    +----+--------------+------------------------+
    |種類 プライオリティ 処理内容                |
    +    +              +                        +
    |High 20             コントローラとの通信処理|
    |Low  46             その他の処理            |
    +----+--------------+------------------------+
    
    スレッドプライオリティを上記のデフォルト値以外に設定したい場合は
    sceSifLoadModule()でpadman.irxをロードする際に、第3引数で指定すること
    ができます。次に示すのは、High = 32, Low = 34と設定する例です。
    
        char* mes = "thpri=32,34";
        sceSifLoadModule( "host0:/usr/local/sce/iop/modules/padman.irx", 
        strlen(mes)+1, mes );
    
    同様にsio2man.irxでも、起動時にスレッドプライオリティを指定できるよう
    になりました。
    
    注意：
    padman.irx, sio2man.irxの動作中にスレッドプラオリティを変更する機能は
    追加する予定はありません。
    

 3 ライブラリの動作
--------------------


  3.1 コントローラデータの読み取りタイミング

    コントローラライブラリの主な処理、つまりコントローラとの通信は、IOP上
    のpadman.irxによって自動的に行われます。通信は１フレームに１回、
    VBlank割り込みによって行われ、通信結果はそのつどEE側のメインメモリに
    DMAで送られ、scePadRead()などの関数で取得することができます。つまり、
    EE側で動作するアプリケーションは任意のタイミングでlibpadの関数を呼び
    出してコントローラのデータを読むことができますが、そのデータは最大で
    1Vsync前の状態を表していることになります。
    
    
    コントローラと通信を行うタイミングは、将来アプリケーションから自由に
    設定できるように機能拡張される予定です。ただ、同じコントローラに対し
    て通信する間隔は、最小で１フレームほど必要です。

  3.2 非同期処理

    コントローラのモード設定を行うscePadSetMainMode()など、コントローラ側
    の処理に数フレームの時間を要する以下の関数は非同期関数として実装され
    ています。
    
    +--------------------+------------------------------------+
    |関数名               機能                                |
    +                    +                                    +
    |scePadSetMainMode    コントローラモードの切り替え／ロック|
    |scePadSetActAlign    アクチュエータパラメータの内容設定  |
    |scePadEnterPressMode 感圧モードへの移行                  |
    |scePadExitPressMode  感圧モードからの抜け出し            |
    +--------------------+------------------------------------+
    
    これらの関数を呼び出すと直ちにリターンしますが、処理の終了は
    scePadGetState()またはscePadGetReqState()で調べる必要があります。

 4 注意事項
------------


  4.1 動作環境

         (1) libpadは、開発ツールDTL-T10000で動作が確認されています。これ
             以外の開発機材（EB-2000など）では動作しません。
         (2) libpadと、fileio.irxモジュールが提供するsceOpen()で使用する
             pad/padsドライバとは共存できません。これらのドライバは実行し
             ないでください。また、これらのドライバを使用する場合はpadman.
             irxをロードしないようにしてください。

  4.2 ガンコントローラについて

    ガンコントローラに対応したアプリケーションを作成する場合は、IOP側の負
    荷に注意してください。ガンコントローラはその特性上、VBLANK期間内に通
    信処理を完了しなければなりませんが、IOPで動作するスレッドの負荷状態に
    よってはコントローラモジュール（padman.irx）の処理が遅れ、VBLANK内で
    通信を終えることができず、座標情報が正しく取得できない場合があります。
    また、ガンコントローラをマルチタップに複数接続することはできません。
    ガンコントローラを使用する場合は本体の1P / 2Pまたはマルチタップの1-A、
    2-Aに接続しなければなりません。

  4.3 RPC再入に関する注意

    libpadの関数はSIF RPCを使用しているため、複数のスレッドで利用する場合
    はRPC再入を起さないように注意が必要です。RPC再入については「SIFシステ
    ム」ドキュメントに解説がありますので参照してください。

   (1) RPC WAIT関数

      以下の関数はsceSifBindRpc() / sceSifCallRpc()をWAIT実行します。RPC
      再入に注意するほか、割り込み禁止状態や割り込みハンドラ内で呼び出さ
      ないようにしてください。
         ・scePadEnd()
         ・scePadEnterPressMode()
         ・scePadExitPressMode()
         ・scePadGetSlotMax()
         ・scePadInfoPressMode()
         ・scePadInit()
         ・scePadPortClose()
         ・scePadPortOpen()
         ・scePadSetActAlign()
         ・scePadSetActDirect()
         ・scePadSetMainMode()

   (2) 非RPC関数

      以下の関数はsceSifBindRpc() / sceSifCallRpc()を使用しません。RPC再
      入を考慮することなく使用できます（関数自体が再入可能という意味では
      ありません）。
         ・scePadGetReqState()
         ・scePadGetState()
         ・scePadInfoAct()
         ・scePadInfoComb()
         ・scePadInfoMode()
         ・scePadRead()
         ・scePadReqIntToStr()
         ・scePadStateIntToStr()

  4.4 出力メッセージについて


    "padman: DMA Busy"

      padmanが "padman: DMA Busy" というメッセージを出力する事があります。
      この場合、以下の2通りの可能性が考えられます。
         (1) SIFDMA(またはDMAC全体)が無反応になっている
             この現象は、描画処理などで Dn_CHCR.STR を落としてDMAを停止し
             ているような場合にまれに発生します。
             回避策としては、Dn_CHCR.STRビットを操作する前に、D_ENABLEWに
             よって一度全DMAを一時停止し、Dn_CHCR.STR を落とした後に、DMA
             を再開することで回避可能です。
         (2) EEが停止している
             EEプロセッサが致命的エラーなどでHaltした場合も IOP からの 
             SIFDMAが処理されず、エラーメッセージが出力されるようになりま
             す。
             また、まれに dsedb 側の CTRL-Cにより、プログラムを中止した場
             合にも、表示されるときがあります。

    "PADMAN: *** VBLANK OVERLAP ***"

      padmanが "PADMAN: *** VBLANK OVERLAP ***" というメッセージを出力す
      る事があります。
      これは、コントローラとの通信が1フレーム中に完結できなかったときに表
      示されます。
      具体的には、padman以外のスレッド負荷によって padman のスレッドが動
      けない状態が続き、1フレーム中に行うべき処理を行えなかったときに表示
      されます。
      この場合、padmanは次のフレームにまたがって処理を続けます。その結果、
      この表示の出たフレームは、EE側のボタン情報等が更新されなくなり、
      scePadRead()は前回のボタン情報を返します。
      コントローラのレスポンスがゲーム性に著しい影響をあたえるようなタイ
      トルでは、padmanよりも高いプライオリティで動作している、スレッドの
      負荷を軽減し、padmanの処理の足かせとならないように改善する必要があ
      ります。
