[SCEI CONFIDENTIAL DOCUMENT]
"PlayStation 2" Programmer Tool Runtime Library  Release 2.0
                Copyright (C) 2000 by Sony Computer Entertainment Inc.
                                                   All Rights Reserved
                                                              Aug,2000

----------------------------------------------------------------------
EE Programming Tips 
----------------------------------------------------------------------

EE 上でのプログラミングの際にポイントとなる点、引っかかりやすい点等
をまとめた tips 集です。

========================================================================
=== [ DMA と D$ の writeback ] =========================================
========================================================================

D$ ON の状態で DMA を使う際には、D$ とメインメモリのコンシステンシを保つ
ために、対応するキャッシュラインの writeback を行う必要があります。D$ の
writeback は、カーネルAPIで提供しています。

	カーネルの関数：
	FlushCahce():	D$ 全体を書き戻す
	iFlushCache():	D$ 全体を書き戻す
	SyncDCache():	指定領域を書き戻す
	iSyncDCache():	指定領域を書き戻す

writeback のタイミングは DMA の方向により異なります。

	DMA でメインメモリからデータを送る場合：
	(1) データを D$ を使って設定する。
	(2) D$ を writeback する。
	(3) データをメインメモリからDMA 転送する。

	DMA でメインメモリにデータを受け取る場合：
	(1) D$ を writeback する。
	(2) データをメインメモリに DMA 転送する。
	(3) 転送したデータを D$ を通して使う。（このとき、D$ に目的の
	    データが読み込まれる。）

========================================================================
=== [ DMA と非キャッシュ領域アクセス ] =================================
========================================================================

D$ ON の状態で DMA を使う際に、D$ の writeback をせずに済ませるには非キ
ャッシュ領域アクセスを使用します。
非キャッシュ領域はカーネルのデフォルト設定は以下のとおりです。

	0x20100000 - 0x21ffffff : uncached
	0x30100000 - 0x31ffffff : uncached accelerated

	DMA でメインメモリからデータを送る場合：
	(1) データを非キャッシュ領域から設定する。
	(2) データをメインメモリからDMA 転送する。

	DMA でメインメモリにデータを受け取る場合：
	(1) データをメインメモリに DMA 転送する。
	(2) 転送したデータを非キャッシュ領域を通して使う。

========================================================================
=== [ D$ とデータの 64 byte alignment ] ================================
========================================================================

D$ の writeback を指定領域に対して行う場合、writeback するのはそのデータ
を含む 64 byte バウンダリの領域であることに注意する必要があります。これは、
D$ の 1 ラインが 64 byte によるためです。これにより、例えば writeback す
る領域が 64 byte バウンダリにあっていない場合、期待していない部分も 
writeback されることになります。この部分が別に管理しているデータ領域と重
なっていると、データの値が予期しない値となる場合があります。

D$ の writeback が予期しない動作をする場合、試しにデータを 64 byte バウン
ダリに合わせてみてください。

========================================================================
=== [ D$ ミスの極小化と SPRAM の使用 ]  ================================
========================================================================

EE では D$ ミスによるペナルティはかなり大きくなります。このため、速度が
要求される部分においては D$ ミスを極小化することが必須となります。D$ ミ
スを減らすにはデータ構造を改良してアクセスが局所的になるように工夫するこ
とが重要です。また、D$ アクセスをせずに SPRAM を使うようにするのも効果的
です。 SPRAM に載らないような大きなデータは、 SPRAM への DMA 転送と 
SPRAM 上での処理を多重化することによって高速に処理することが出来ます。

	all data = (data0, data1, data2, data3, data4, ....)

	(1) data0 を SPRAM へ DMA する。
	(2) SPRAM 上で data0 を処理、その裏で data1 を SPRAM へ DMA する。
	(3) SPRAM 上で data1 を処理、その裏で data2 を SPRAM へ DMA する。
	(4) SPRAM 上で data2 を処理、その裏で data3 を SPRAM へ DMA する。
	....
	....

========================================================================
=== [ D$ ミスカウント測定と注意点 ] ====================================
========================================================================

D$ ミスを定量的に測定するために Performance Counter library を利用する
ことができます。Performance Counter library で Counter Event を
 D$ miss に設定することにより D$ miss をカウントします。ただし、このとき
得られる値の解釈には注意が必要です。

D$ miss イベントはロード/ストアの際に、対応するデータが D$ に載っていなか
った場合の回数を示すものです。これは、キャッシュラインがリフィルされる回
数と同一ではありません。例えば、non blocking load で、最初のロードが 
D$ miss し、そのラインを読んでいる最中に次のロードが同じラインをアクセス
した場合には 2 番目のロードも D$ miss としてカウントされます。また、
D$ miss イベントは Uncached のロード/ストアも含みます。

========================================================================
=== [ I$ ミスの極小化 ] ================================================
========================================================================

I$ ミスは D$ ミスと同様に大きなペナルティとなります。このため、速度が要求
される部分においては I$ ミスを極小化することが必須となります。I$ ミスを減
らすには、

	(1) 頻繁に実行されるループとそこから呼ばれる関数のコードサイズを
	    減らす。
	(2) 頻繁に実行されるループから呼ばれる関数をアドレス的にループ自
	    体の近くに置く。

と言った最適化が必要になります。アドレス空間上での関数の配置を変更するた
めには、リンク時のオブジェクトファイルの指定順を変更したり、リンク時に使
用される *.cmd ファイルの書き換えを行ったりします。また、リンクはオブジ
ェクト単位で行われますので、1 つのオブジェクト中に頻繁に呼ばれる関数とあ
まり呼ばれない関数が同居しているのは効率的ではありません。
このため、関数の構成を機能別ではなく、実行される頻度別に変更することも必
要となります。

また、ソースコードに明示的に書かれている関数呼びだし以外でも、コンパイラ
が暗黙に関数呼出しをしてしまうことがあります。これらには型変換のときに使
われるもの等があり、これらの関数が通常の目的の最適化部分とは全く関係ない
場所に置かれることがあります。この場合、これらの関数のアドレスよっては呼
びだし時に I$ ミスを起こすことになります。

このような暗黙に使われてしまう関数を管理するには、逆アセンブルし、呼出し
の有無を確認します。もし、望まない呼出しが起こっている際にはそれを回避す
るために C のソースコード上で、あるいはアセンブリ言語上での変更が必要に
なります。

========================================================================
=== [ I$ ミスカウント測定 ] ============================================
========================================================================

I$ ミスを定量的に測定するには、Performance Counter library (libpc) を利
用することができます。Performance Counter library で Counter Event を I$
 miss に設定することにより I$ miss をカウントします。

========================================================================
=== [ コンパイラが暗黙にリンクする関数 ] ===============================
========================================================================

ソースコードに明示的に書かれている関数呼びだし以外でも、コンパイラが暗黙
に関数呼出しをしてしまうことがあります。これらには型変換の際に使われるも
の等があります。

	例：.
	dptofp(): (double -> float)
	fptodp(): (float -> double)
	fptosi(): (float -> int)
	fptoui(): (float -> unsigned int)

これらはもちろん正常に動作しますが、効率という観点から見た場合、

	(1) 関数呼出しのオーバーヘッドがある
	(2) 必ずしも必要でない重い処理である
	(3) 場合によっては余分な I$ miss を起こす

と言う問題があります。効率を優先する個所においては、これらの関数呼出しが
起こらないように最適化することが必要です。多くの場合は、コードの書き方を
変更することによって改善できます。それでも不十分である場合には直接アセン
ブリ言語で記述します。

========================================================================
=== [ 浮動小数点定数の宣言 ] ===========================================
========================================================================

浮動小数点定数の型は明示的に接尾辞によって指定しない限り double になりま
す。これを避けるには、次のように明示的に接尾辞 f/F を指定するか強制的に
キャストする必要があります。

	1.0f
	(float)1.0

次のコード

	float addone(float a)
	{
	 return a + 1.0;
	}

では、1.0 が double として取り扱われるため、

	(1) a + 1.0 : double の加算 ... 関数 dpadd()
	(2) double -> float の変換  ... 関数 dptofp()
    
という２つの関数が addone() 中で暗黙のうちに呼ばれます。 addone() が頻
繁に呼ばれる関数だとすると、これだけで大きな性能低下を引き起こすことも
あり得ます。これを避けるためには、

    float addone(float a)
    {
	 return a + 1.0f;
    }

と記述します。

また、これとは別に ee-gcc のオプション -fshort-double でもこの問題を回
避することが出来ます。-fshort-double は、double のサイズを float と同じ
サイズとして定義するオプションです。このため、1.0 のように接尾辞をつけ
ない場合でも float で宣言したときと同じように扱うことが出来ます。

ただし、このオプションを指定してコンパイルしたオブジェクトファイルと、
指定せずにコンパイルしたオブジェクトファイルをリンクする際は、両者の間に
double によるインタフェースがないことを明確にしておかなければなりません。
すなわち、大域変数や関数のパラメータ、返り値の型に double があってはいけ
ません。特に、標準ライブラリの使用に際しては注意が必要です。
例えば printf() に浮動小数点型のパラメータを渡す場合、それは必ず double 
に変換されますが、-fshort-double を指定していると、倍精度ではなく単精度
のまま printf() に渡されることになり、正しい結果を得ることができなくなり
ます。これは、printf() が -fshort-double を指定せずにコンパイルされてい
るため、倍精度の値が渡されることを期待することによるものです。

========================================================================
=== [ データのセクション指定 ] =========================================
========================================================================

ee-gcc でデータセクションを指定するには次のように指定します。

	例： bss セクションに置く 
	unsigned char data[100] __attribute__((section (".bss")));

この例では data は未初期化の変数なので何も指定しなくても bss セクション
に置かれます。

========================================================================
=== [ データのアラインメント指定 ] =====================================
========================================================================

ee-gcc でデータのアラインメントを指定するには次のように指定します。これ
はグローバル変数および static 変数にのみ有効で、自動変数については無効に
なります。

	(1) 初期値のある static/global 変数

	unsigned char data[] __attribute__ ((aligned(16))) = {
	  a', 'b', 'c'
	};

	(2) 初期値のない static/global 変数

	unsigned char data[1*1024*1024] __attribute__ ((aligned(16)));

	ee-gcc のバージョン: 2.9-ee-991111-01
	バージョン番号は ee-gcc -v で表示されます。

========================================================================
=== [ 一度の DMA で指定できるサイズ ] ==================================
========================================================================

1 回の Normal DMA および、1 つの DMA タグで指定できるデータのサイズは、
1 MB 未満です。これらは、QWC フィールドが 16 bit であることから自明です
が、実際のコーディング中に陥りやすい点です。これは通常「データを大きくし
たら動かなくなった」等の現象として現れます。 1 MB 以上のデータを DMA 転
送するためには、全体を 1MB 以下のブロックに分け、それぞれに DMA tag を
指定して chain モード を使う必要があります。

========================================================================
=== [ write buffer のレイテンシ ] ======================================
========================================================================

メインメモリのアドレス空間にマップされたデバイスのレジスタやメモリ等に、
CPU-core から書き込みを行った場合、必 ずwrite-buffer を経由します。
write-buffer は、メインバスを使用できるようになるまでフラッシュされませ
ん。そのため、CPU-core で store 命令を実行したタイミングと実際にデバイス
に書き込まれるタイミングは、大きくずれることがあります。デバイスに書き
込まれたことを保証するためには、以下の２つの方法があります。

	(1)書き込み後に、そのレジスタと同じアドレスを空読みする。
	(2)書き込み後に、
		__asm__ __volatile__(" sync.l");
	  を入れる。

========================================================================
=== [ VU0 の m ビット ] ================================================
========================================================================

VU では以下の場合のみを保証しています。

      COP2     |       VU0
               |    M=0      ↑
       (1)     |    M=0      ｜インタロックする領域
               |    M=0      ↓
       (2)     |    M=1      ↑
               |    M=1      ｜
       (3)     |    M=1      ｜インタロックしない領域
               |    M=1      ｜
               |    M=1 E=1  ↓

ユーザは、一度でも m ビットを 1 にセットした場合、それ以降、1 をセットし
続けなければなりません。

これは以下のような場合の動作を保証出来ないためです。

      COP2     |       VU0
               |    M=0
       (1)     |    M=0
               |    M=0
       (2)     |    M=1
               |    M=0
       (3)     |    M=1
               |    M=0
               |    M=1 E=1

また、1 命令のみ m ビットに 1を指定したとしても、その命令が VU の T ス
テージでストールするならば、その VU のストールサイクル分 core 側に 
QMTC2.i/CTC2.i のストール解除が伝わる事になります。

よって、VCALLMS を実行後、QMTC2.I,CTC2.I のように m ビットによる同期を
行う場合、１回の VCALLMS の内部で 2 度以上の同期を行うようなコードを書
かないようにする必要があります。

========================================================================
=== [ VU1 起動時の注意 ] ===============================================
========================================================================

R5900 store で VU1-micro-memory にマイクロ命令を書き込んだ後に VU1 を 
起動するためには、write buffer などを通過して、完全に書き込まれた後に
起動しなければなりません。

そのためのマナーとして以下を参考にして下さい。

$10 は VU1-uRAM area 領域のどこかのアドレスと想定して、

	sd ........... マイクロ命令のセット
/**/
	ld	$10,($10)	/* access VU1-uRAM area (uncached area) */
	sync.l			/* Waiting for reading data from vu1-uRAM */
	sync.p			/* flush pipeline */
/**/
	ctc2 ........  VU1 の起動 (CMSAR1 への write)


========================================================================
=== [ VCALLMS/R使用上の注意 ] ==========================================
========================================================================

1. VUのマイクロプログラミングで、最後のマイクロ命令 (Ebit=1 の次の命令)
  では，リソースハザードやデータハザードや同期命令によるインターロックが
  生じないように命令を選んでください。

あるいは、

2. 最後のマイクロ命令 (Ebit=1 の次の命令) で、リソースハザードやデータハ
  ザードや同期命令によるインターロックが生じる可能性がある場合は、CPU コ
  アのプログラミングで、vcallms/r 命令の後に、必ずマクロ命令あるいはイン
  ターロック付の cop2move 命令を入れ、vcallms/r 命令が連続しないようにし
  てください。

この様に行わない場合、以下のようにマイクロ命令が kill されます。

1. vcallms/r 命令が連続していて (間に COP2 以外の命令がはさまれるケースも
  含む)、後続の vcallms/r 命令が、先行する vcallms/r 命令のマイクロ命令
  終了を待ってストールする。
2. 先行している vcallms/r 命令の最後のマイクロ命令 (Ebit=1の次の命令) が
  がリソースハザードやデータハザードや同期命令でストールする。
3. 先行する vcallms/r 命令の最後のマイクロ命令がストール中に、後続する
  vcallms/r 命令がWステージに進み、Wステージで例外を検出する。
4. 例外を検出した後続の vcallms/r 命令だけでなく、先行する vcallms/r 命令
  のストール中のマイクロ命令も kill される。

========================================================================
=== [ 128 bit 整数の宣言 ] =============================================
========================================================================

128 bit 長の整数は次のように宣言します。

	符号付き 128 bit 整数：
    	long128 a;

	符号なし 128 bit 整数：
	u_long128 a;

long128、u_long128 は eetypes.h に次のとおりに定義されています。

	typedef int long128 __attribute__ ((mode (TI)));
	typedef unsigned int u_long128 __attribute__ ((mode (TI)));

long128 および u_long128 は 128 bit 境界に置かれることが保証されます。
また、それぞれの型の間での代入は通常の型のように記述できます。このとき、
代入には lq, sq といった 128 ビット長の命令が使われます。

long128、u_long128 は四則演算等、通常の型に対して使用できる通常の演算子
は使用することができません。u_long128、long128 は代入のみをサポートします。

========================================================================
=== [ VU0マクロモードにおけるフラグレジスタ参照時の注意 ] ==============
========================================================================

VU0マクロモードで分岐を実行したい場合、処理をEEcore側で実装する必要が有
ります。その際、MACフラグなどを cfc2 命令によってEEcoreレジスタにもって
くることになります。

(安全な例)
    vsuby.x vf13x, vf12x, vf15y 
    vnop
    vnop
    vnop
    vnop
    vnop
    cfc2    $11, $vi17  #(just 5 latency) 

この例ではvnopを間にはさみ、vsub 命令のフラグが有効になるタイミングを合
わせています。ですがこのとき、vnop以外の命令でタイミングを合わせるのは
危険ですから注意してください。

(危険な例) vadd を入れた場合
  ---------------------------------------------------------------
    vsuby.x vf13x, vf12x, vf15y   ↑
    vnop                          ｜
    vnop                          ｜ I-cacheにのっている領域
    vnop                          ｜
    vnop                          ｜
    vaddy.x vf18x, vf12x, vf15y   ↓
  ---------------------------------------------------------------
    cfc2  $11, $vi17  #(5latency) ↓ I-cacheにのっていない領域

この場合 cfc2 命令の直前で I-cacheミスを発生し、EEcore側はストールしてし
てしまいます。しかしその間も VU0 のパイプラインは実行を続けますので、
cfc2 命令が実行されるころには直前の vadd 命令の結果がMACフラグに反映され
てしまいます。その結果誤ったフラグ判定をしてしまうことになります。

したがって、フラグを変更する命令を間に入れてはいけません。もし、どうして
も他の処理を入れたい場合は次のようにする方法が考えられます。

１、フラグを変えない安全な命令を挿入する。(EEcore命令やCOP2転送命令など)
２、マクロモードは使用せず，マイクロモードで実装する．
３、フラグ判定したい命令から ctc2 命令までが、同時に On-Cache になるよう
    アライメントをそろえる。(推奨しない)






