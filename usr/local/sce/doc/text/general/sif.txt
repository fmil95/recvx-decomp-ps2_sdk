[SCEI CONFIDENTIAL DOCUMENT]
"PlayStation 2" Programmer Tool Runtime Library Release 2.0
                  Copyright (C) 2000 by Sony Computer Entertainment Inc.
                                                     All Rights Reserved

SIFシステム
============


 1 SIFシステムの構成
---------------------

    SIF(SubBus I/F)を介してEE - IOP間の通信を行うSIFシステムは、次のよう
    な階層構造で構成されています。
    
    
    SIF DMA / SIF CMD / SIF RPC(Remote Procedure Call)という3つのレベルで、
    EE側 / IOP側双方にそれぞれほぼ同一のAPIが用意されています。

 2 SIF DMA API
---------------


  2.1 概要

    SIF DMA APIはSIFシステムのもっとも下位の階層となるAPIです。EEからIOP
    へ、逆にIOPからEEへ、それぞれ相手側メモリへのDMA転送を行う関数と、転
    送処理の状態を調べる関数、DMAチャネルの再設定を行う関数が用意されてい
    ます。
    
    
    EE側IOP側ともにSIF DMAの受け口は基本的に常時開いていますので、相手側
    メモリへのDMA転送は非同期に（相手側の状態を意識せずに）実行することが
    できます。ただし、EEが受け手となる転送の際に、DMA終了割り込みが発生す
    ると、EE側の受け口が閉じます。またIOPが受け手となる転送の際に、
    SIF_DMA_ERTを指定してDMA終了割り込みを発生させると、IOP側の受け口が閉
    じます。いずれの場合も、受け手側でDMAチャネルの再設定を行って受け口を
    開きなおす必要があります。

  2.2 関連ファイル

    SIF DMA APIを利用するのに必要なファイルは次のとおりです。
    
    +--------------+----------+
    |カテゴリ       ファイル名|
    +              +          +
    |ヘッダファイル sif.h     |
    |EE ライブラリ  libkernl.a|
    |IOP モジュール iop.ilb   |
    +--------------+----------+

 3 SIF Command API
-------------------


  3.1 概要

    SIF CMD(Command) APIはSIF DMA APIの上位階層に位置し、EE / IOPそれぞれ
    相手側でローカルに定義し登録した関数（コマンド関数）を、コマンドパケ
    ットを送ることによって実行させる仕組みです。たとえば、IOP側でIOPアプ
    リケーションの変数を変更するコマンド関数を登録しておけば、EE側からIOP
    アプリケーションの動作を制御することができます。また逆に、EE側にコマ
    ンド関数を登録しておいて、IOPアプリケーションからの指示に応じてアクシ
    ョンを起すこともできます。EE側 / IOP側ともに、ほぼ同一のAPIが実装され
    ています。
    
    
    SIF CMD APIは、SIF DMA APIと並行して使用することができます。

  3.2 関連ファイル

    SIF CMD APIを利用するのに必要なファイルは次のとおりです。
    
    +--------------+----------+
    |カテゴリ       ファイル名|
    +              +          +
    |ヘッダファイル sifcmd.h  |
    |EEライブラリ   Libkernl.a|
    |IOPモジュール  iop.ilb   |
    +--------------+----------+

  3.3 利用手順

    まず、初期設定としてEE / IOP双方でsceSifInitCmd()を呼び出します。この
    ときの内部動作は次のとおりです。
         (1) 受信バッファ（8qword）を確保し、そのアドレスを交換する。
         (2) SIF CMD用の割り込みハンドラを登録する。
         (3) ソフトウエアレジスタを初期化する。
    次に、受け手となるプロセッサの側でsceSetCmdBuffer()を呼び出し、コマン
    ド関数登録用のバッファ（テーブル）を登録します。さらに、
    sceSifAddCmdHandler()を呼び出し、コマンド関数を登録します。コマンド関
    数は、割り込み関数として実行されます。コマンド関数を複数登録する場合
    は、必要なだけsceSifAddCmdHandler()を繰り返します。
    あとは必要に応じて、適切なコマンドパケットを用意しsceSifSendCmd()を呼
    び出すことによって、受け手プロセッサに送り実行させます。このときの内
    部動作は次のとおりです。
         (1) コマンドパケットを相手側の受信バッファへ転送し、転送終了割り
             込みを発生させる。
         (2) 受け手側でSIF CMD用の割り込みハンドラが動き、受信バッファを検
             索する。
         (3) 受信バッファにコマンドパケットがあれば、パケットを解析し、適
             切なコマンド関数を割り込み領域で実行する。
             受信バッファにデータが何もなければ、そのままリターンする。

  3.4 サンプルプログラム

    SIF CMD APIを使用するプログラム例として、/sce/ee/sample/sif/sifcmdお
    よび/sce/iop/sample/sif/sifcmdがあります。

 4 SIF RPC API
---------------


  4.1 概要

    SIF RPC(Remote Procedure Call) APIは、SIF CMD API上に作られた、単純な
    クライアントサーバモデルを構築する仕組みです。たとえば、IOP側で登録し
    た関数をEEアプリケーションから呼び出し、結果をEEアプリケーションに返
    させるといったことができます。
    
    
    EE / IOP双方にほぼ同一のAPIが用意されているので、上図とは逆にEE側がサ
    ーバとなりIOP側がクライアントとなることも可能ですし、両方の役割を同時
    にこなすことも可能です。
    また、SIF RPC APIは、SIF DMA API / SIF CMD APIと並行して使用可能です。

  4.2 関連ファイル

    SIF RPC APIを利用するのに必要なファイルは次のとおりです。
    
    +--------------+----------+
    |カテゴリ       ファイル名|
    +              +          +
    |ヘッダファイル sifrpc.h  |
    |EE ライブラリ  libkernl.a|
    |IOP モジュール iop.ilb   |
    +--------------+----------+
    

  4.3 利用手順

    SIF RPC APIを使用する際の手順をまとめると次のようになります。
    
    サーバ側のサービスループ内では、クライアント側からのリクエストがない
    場合、そのサービスループを呼び出したスレッドはリクエストが来るまでは
    スリープ状態になっています。
    クライアント側の関数sceSifBindRpc()およびsceSifCallRpc()では、この関
    数を呼び出したスレッドはサーバ側から応答があるまで、セマフォもしくは
    イベントフラグによる待ちの状態になっています（同期呼び出し、または
    WAIT実行といいます）。また、待ちの状態にならないように呼び出して、
    sceSifCheckStatRpc()で処理終了を確認することも可能です（非同期呼び出
    し、またはNOWAIT実行といいます）。
    なお、同期呼び出しの場合、サービス関数の処理終了はサーバ側からのDMA割
    り込みで通知されます。したがって、割り込み禁止状態または割り込みハン
    ドラ内で同期呼び出しを行うとハングアップしますので注意してください。

  4.4 標準サービス関数

    EE側をクライアントとするサービス関数として、入出力サービスと標準IOPサ
    ービスの2つが提供されています。詳細はそれぞれ別ドキュメント（libio / 
    libiserv）にまとめてありますので参照してください。

  4.5 サンプルプログラム

    SIF RPC APIを使用するプログラム例として、/sce/ee/sample/sif/sifrpcお
    よび/sce/ee/sample/sif/sifrpcがあります。

 5 RPC再入に関する注意
-----------------------


  5.1 RPC再入のしくみ

    SIF RPC APIで呼び出すサービス関数は再入不可能です。関数自体が再入可能
    （リエントラント）にコーディングされていても、RPC経由での再入はできま
    せん。
    クライアント側から見ると、あるサービス関数をsceSifCallRpc()で呼び出し
    たらその処理が終了しないうちに重ねて呼び出すことはできない、というこ
    とになります。もし重ねて呼び出すと、多くの場合、適切なデータが得られ
    ずクライアント側でライブラリの内部関数 _sceRpcFreePacket()がハングア
    ップするという症状が現れます。
    このような再入が引き起こされるのは、複数のスレッドで同じサービス関数
    を利用している場合、さらに詳しく言うと次の2つのケースです。

    WAIT実行で再入が起こるケース

         (1) あるスレッド(A)でsceSifCallRpc(&bd)をWAIT実行する
         (2) sceSifCallRpc(&bd)内部でセマフォ待ちに入り、別のスレッド(B)に
             実行権が移る
         (3) スレッド(B)でsceSifCallRpc(&bd)を実行する……(1)の
             sceSifCallRpc(&bd)が終了していなければ再入が起こる

    NOWAIT実行で再入が起こるケース

         (1) あるスレッド(A)でsceSifCallRpc(&bd)をNOWAIT実行する
         (2) 何らかの割り込みが起こり、割り込みハンドラに制御が移る
         (3) 割り込みハンドラ内部で、スレッド(A)より優先度の高いスレッド
             (B)が起床される
         (4) 割り込みハンドラから復帰し、スレッド(B)に実行権が移る
         (5) スレッド(B)でsceSifCallRpc(&bd)を実行する……(1)の
             sceSifCallRpc(&bd)が終了していなければ再入が起こる

  5.2 RPC再入の防止

    RPC再入が起こらないようにするには、次のような方法があります。
         ・同じClientDataを使用するsceSifCallRpc()はひとつのスレッドでまと
           めて実行する
         ・同じClientDataを使用するsceSifCallRpc()を複数のスレッドで実行す
           る場合は、セマフォ等を用いて排他制御する（スレッドセーフな構造）

  5.3 RPCを使用するライブラリ関数

    SCEが提供しているライブラリ関数のうち以下に挙げるものは、内部で
    sceSifCallRpc()を使用しています。基本的に、同じライブラリに属する関数
    は同じClientDataを使用していますので、上記のような方法で、RPC再入が起
    こらないように注意して利用してください。
         ・libpadの一部の関数
         ・libmtapの各関数
         ・libmcのほとんどの関数
         ・libmcxのほどんどの関数
         ・libcdvdのほとんどの関数
         ・libsdrの一部の関数
         ・標準IOPサービスのほとんどの関数
         ・入出力サービスのほとんどの関数
    詳細は各ライブラリのオーバービューを参照してください。

 6 IOPモジュールの置き換え
---------------------------


  6.1 デフォルトモジュールの置き換え

    IOP側にはデフォルトでいくつかのモジュールがROMからロードされています
    が、これを置き換えるためには、いったんIOPシステムをリブートしてOSを再
    起動する必要があります。その際に、リプレースモジュール（置き換える新
    しいモジュール）をイメージファイルとして指定します。イメージファイル
    はライブラリのバージョンに合わせて提供されます。
    アプリケーションでは、ディスクから起動後すぐにIOPをリブートしてデフォ
    ルトモジュールを置き換えるようにしてください。プログラム例を以下に示
    します。
    
        #include <eekernel.h>
        #include <eeregs.h>
        #include <sifdev.h>
        #include <stdio.h>
        #include <libcdvd.h>
        
        #define DISK_BOOT  /* ディスクから起動する場合（T10000での開発中
        は外す）*/
        
        int main()
        {
         sceSifInitRpc(0);
         /* DiskReady待ち*/
         sceCdInit(SCECdINIT);
        #ifdef DISK_BOOT
         /* IOPリブート・デフォルトモジュールの置き換え*/
         while ( !sceSifRebootIop("cdrom0:\\IOP14.IMG;1") );
         while( !sceSifSyncIop() );
         /* 再初期化*/
         sceSifInitRpc(0);
         sceCdInit(SCECdINIT);
         sceFsReset();
        #endif
         /* デフォルト以外のモジュールの起動*/
         while (sceSifLoadModule("cdrom0:\\SIO2MAN.IRX;1",0,NULL) < 0);
         while (sceSifLoadModule("cdrom0:\\PADMAN.IRX;1",0,NULL) < 0);
           :
           :
        }
    
    sceSifRebootIop()を発行してsceSifSyncIop()が0以外を返すまでの間、
    printf()を含めて、IOPを介するサービスは一切使用できません（GSやEEのコ
    プロセッサの制御は可能です）。
    また、SIFCMD / SIFRPCおよびDECIの設定もすべてリセットされますので、再
    設定を行ってください。sceOpen() / sceRead()についてはsceFsReset()、
    libcdvdについては、sceCdInit()を呼び出します。

  6.2 デフォルト以外のモジュールの置き換え

    デフォルト以外のモジュールを置き換えるには、上記のプログラム例にもあ
    りますが、IOPをリブートしてから再びsceSifLoadModule()を実行してくださ
    い。

  6.3 IOPモジュールのスレッドプライオリティ指定

    sceSifLoadModule()でIOP側モジュールを起動する際に、そのモジュールが実
    行されるスレッドのプライオリティを指定することができます。次に示すよ
    うに、第3引数で指定してください。
    padの場合：
        char* mes = "thpri=32,34"; <- 変更したい値を設定する
        sceSifLoadModule( "host0:/usr/local/sce/iop/modules/padman.irx", 
        strlen(mes)+1, mes );
    
    また、IOP側モジュールを持つ各ライブラリ（libpadを除く）には、動作中の
    モジュールのスレッドプライオリティを変更する関数（
    sceXXXChangeThreadPriority()）が用意されています。
    詳しくは各ライブラリのドキュメントを参照してください。
