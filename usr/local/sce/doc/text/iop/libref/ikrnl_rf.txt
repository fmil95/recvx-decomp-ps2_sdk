[SCEI CONFIDENTIAL DOCUMENT]
"PlayStation 2" Programmer Tool Runtime Library Release 2.0
                  Copyright (C)  2000 by Sony Computer Entertainment Inc.
                                                     All Rights Reserved

                          IOPカーネルライブラリ
                         ======================

    

 1 システムメモリ管理関数
==========================

=========================================================================
AllocSysMemory                                                     [関数]
=========================================================================
                                                  メモリエリアの割り当て
[形式]
        void * AllocSysMemory(int type, unsigned long size, void *addr);
        
[引数]
        type	0,1,2 のいずれかを指定し、メモリの割り当て方針を指定します。
        size	割り当てメモリサイズを byte単位で指定します。
        addr	type==2 の時、アドレスを指定します。
        
[返り値]
        非NULL		割り当てたメモリの先頭アドレス
        NULL		割り当て失敗
        
[解説]
        size で指定した バイト数のメモリを割り当てます。
        type が 0 の場合は、メモリアドレスの若い方から空きエリアをさがし
        て、割り当てます。
        type が 1 の場合は、メモリアドレスの大きい方から空きエリアをさが
        して、割り当てます。
        type が 2 の場合は、addrで指定したアドレスから割り当てます。
        
[備考]
        割り込み禁止状態で呼んでください。

=========================================================================
FreeSysMemory                                                      [関数]
=========================================================================
                                                      メモリエリアの解放
[形式]
        int FreeSysMemory(void *area);
        
[引数]
        area	解放するメモリエリアの先頭アドレス
        
[返り値]
        KE_OK		正常終了
        KE_ERROR	指定した area は割り当てられていなかった
        
[解説]
        area で指定したメモリエリアを解放します。
        
[備考]
        割り込み禁止状態で呼んでください。
        

=========================================================================
QueryMaxFreeMemSize                                                [関数]
=========================================================================
                                      割り当て可能最大メモリサイズの取得
[形式]
        unsigned long QueryMaxFreeMemSize();
        
[引数]
        なし
        
[返り値]
        正(>=0)	割り当て可能な最大メモリブロックのバイト数
        
[解説]
        割り当て可能なメモリブロックのうちもっとも大きなブロックのサイズ
        を取得します。
        

=========================================================================
QueryMemSize                                                       [関数]
=========================================================================
                                                     全メモリサイズの取得
[形式]
        unsigned long QueryMemSize();
        
[引数]
        なし
        
[返り値]
        正(>0)	管理対象のメモリ総バイト数
        
[解説]
        システムメモリマネージャの管理対象となるメモリのサイズを取得しま
        す。
        

=========================================================================
QueryTotalFreeMemSize                                              [関数]
=========================================================================
                                      割り当て可能メモリサイズ総計の取得
[形式]
        unsigned long QueryTotalFreeMemSize();
        
[引数]
        なし
        
[返り値]
        正(>=0)	割り当て可能なメモリの総バイト数
        
[解説]
        割り当て可能メモリサイズ総計を取得します。
        

 2 モジュール管理関数
======================


=========================================================================
LoadStartModule                                                    [関数]
=========================================================================
                    プログラムモジュールをファイルからロードして起動する
[形式]
        int LoadStartModule(const char *filename, int args, const char *a
        rgp, int *result);
        
[引数]
        filename プログラムモジュールの格納されたファイルの名称を指定しま
        	 す。
        	 プログラムモジュールの argv[0] に渡される文字列としても
		 使用されます。
        args	 argp が指している文字配列の有効データ数を指定します。
        argp	 引数文字列を格納した文字配列。
        	 引数文字列は null terminate された複数の文字列を連続して格
		 納します。
        result	 モジュールの初期化ルーチンが返す戻り値を格納する変数へのポ
        	 インタを指定します。
        
[返り値]
        正(>=0)			ロードしたモジュールのID番号
        KE_ILLEGAL_OBJECT	オブジェクトファイルの形式が正しくない
        KE_LINKERR		ロードしたモジュールが必要とする常駐ライブ
				ラリが存在しない
        KE_NOFILE		指定したファイルが見つからない
        KE_FILEERR		ファイルの読み込み時にエラー発生
        KE_NO_MEMORY		メモリ不足
        
[解説]
        プログラムモジュールをファイルからロードして起動します。

=========================================================================
RegisterLibraryEntries                                             [関数]
=========================================================================
                              常駐ライブラリのエントリテーブルを登録する
[形式]
        int RegisterLibraryEntries(libhead *lib);
        
[引数]
        lib	ユーティリティ loplibgen が生成したエントリテーブルへの
		ポインタ
        
[返り値]
        KE_OK		正常
        KE_ERROR	登録失敗
        
[解説]
        常駐ライブラリのエントリテーブルをシステムに登録します。
        常駐するプログラムモジュールは、任意の個数のエントリテーブルを登
        録することができます。
        

 3 スレッド管理関数
====================


=========================================================================
ChangeThreadPriority / iChangeThreadPriority                       [関数]
=========================================================================
                                                    スレッドの優先度変更
[形式]
        int ChangeThreadPriority( int thid, int priority );
        int iChangeThreadPriority( int thid, int priority );
        
[引数]
        thid	  優先度を変更するスレッドのスレッドIDを指定します。
        	  TH_SELF(=0)で、自スレッドを指定できます。
        priority  変更後の優先度を指定します。
        	LOWEST_PRIORITY(=126)からHIGHEST_PRIORITY(=1)が指定可能で、		        数の小さい方が高い優先度となります。
        	通常は、USER_LOWEST_PRIORITY(=123)からUSER_HIGHEST_PRIORITY
		(=9)の範囲を使用します。
        	TPRI_RUN(=0)を指定することにより、自スレッドの現在の優先度
		を指定できます。
        
[返り値]
        KE_OK			正常
        KE_UNKNOWN_THID		対象スレッドが存在しない
        KE_ILLEGAL_PRIORITY	優先度の指定が不正
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだ
				しだった
        KE_DORMANT		対象のスレッドはDORMANT状態だった
        
[解説]
        thid で指定されたスレッドの優先度を priority に変更します。
        
        このサービスコールで変更した優先度は、再び変更しない限りスレッド
        が終了するまで有効です。
        スレッドが DORMANT状態になると、終了時のスレッドの優先度は捨てら
        れて、次にスレッドが起動されたときの優先度はスレッド生成時に指定
        された起動時優先度(initPriority)になります。
        
        対象スレッドがレディキューや何らかの待ち行列につながれていた場合
        には、このサービスコールによって行列の順番が変ることがあります。
        レディキューの中のスレッド(RUN状態のスレッドも含む)または優先度順
        の待ち行列の中のスレッドに対して ChangeThreadPriority() が実行さ
        れた場合、対象スレッドはキューの該当優先度の部分の最後尾に移動し
        ます。以前と同じ優先度を指定した場合も、同様にキューのその優先度
        の部分の最後尾に移動します。したがって、自スレッドを対象として現
        在と同じ優先度の ChangeThreadPriority()を発行することにより、実行
        権の放棄を行うことができます。
        

=========================================================================
CheckThreadStack                                                   [関数]
=========================================================================
                                      スレッドのスタックの残り容量を取得
[形式]
        int CheckThreadStack();
        
[引数]
        なし
        
[返り値]
        スレッドのスタックの残りサイズ
        
[解説]
        自スレッドのスタックがあとどれくらい空いているかを計算します。
        この関数は、スレッドの必要スタックサイズを決定するための支援用の
        関数です。
        計算結果が、明らかにスタックオーバーフローを起こしている場合は、
        警告を表示した後、システムが停止します。
        

=========================================================================
CreateThread                                                       [関数]
=========================================================================
                                                            スレッド生成
[形式]
        int CreateThread( struct ThreadParam *param );
        
[引数]
        param	生成するスレッドの設定情報をもつ構造体変数へのポインタを指
        定します。
        	以下のメンバがあります。
        	int	attr;
        	void	*entry;
        	int	initPriority;
        	int	stackSize;
        	u_int	option;
        各メンバの内容は以下の通りです。
        	attr	スレッドの記述言語を示す、TH_ASM または TH_C を
			指定します。
        		オプションとして TH_COP1, TH_COP2, TH_COP3 を論理和
			で指定できます。
        		TH_COP1, TH_COP2, TH_COP3 は指定したコプロセッサを 			        新規スレッドからアクセスできるようにすることを指定
			します。
        	entry	スレッドのエントリアドレスを指定します。
        		スレッドのエントリポイントとなる関数は引数をひとつ
			持つことができます。
        		引数は後述の StartThread() で与えられます。
        	nitPriority スレッド起動時(StartThread())の優先度を指定しま
			す。
        		LOWEST_PRIORITY(=126)からHIGHEST_PRIORITY(=1)が指定
			可能で、数の小さい方が高い優先度となります。
        		通常は、USER_LOWEST_PRIORITY(=123)から
        		USER_HIGHEST_PRIORITY(=9)の範囲を使用します。
        	stackSize スレッドの必要スタックサイズを byte 単位で指定し
			ます。
        		外部割り込み発生時にレジスタを待避するために 
			150byteのスタックが使用されるので、この分の余裕を
			見込んでスタックサイズを指定してください。
        		300 byte 以下のスタックサイズを指定した場合はエラー
			になります。
        	option	スレッドに関する付加情報。
        		この値は、ReferThreadStatus()で参照できます。
        		マルチスレッドマネージャはこの値を関知しません。
        		起動されるスレッドに対する引数などに利用できます。
        		後述の StartThread() の arg 引数との違いは、スレッ
			ドがDORMANT状態になっても保持されることです。
        		u_long に入りきらない情報を渡したいときは、別途
			メモリを確保してそのアドレスを渡してください。
        
[返り値]
        正(>0)			スレッドのID
        KE_NO_MEMORY		メモリ不足
        KE_ILLEGAL_ATTR		attr の指定が不正
        KE_ILLEGAL_STACK_SIZE	スタックサイズの指定が不正
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだ
				しだった
        KE_ILLEGAL_PRIORITY	優先度の指定が不正
        KE_ILLEGAL_ENTRY	スレッドの entry アドレスが不正
        
[解説]
        スレッドを生成します。
        生成するスレッドに対して スレッド管理領域を割り付けその初期設定を
        行い、スタック領域を確保します。
        生成するスレッドの情報を param で指定し、戻り値にスレッドのIDが返
        ってきます。
        生成されたスレッドは DORMANT状態になります。
        

=========================================================================
DeleteThread                                                       [関数]
=========================================================================
                                                             スレッド削除
[形式]
        int DeleteThread( int thid );
        
[引数]
        thid	削除するスレッドの ID を指定します。
        
[返り値]
        KE_OK			正常
        KE_UNKNOWN_THID		対象スレッドが存在しない
        KE_ILLEGAL_CONTEXT 	例外ハンドラ／割り込みハンドラからの呼びだ
				しだった
        KE_NOT_DORMANT		対象のスレッドはDORMANT状態ではなかった
        
[解説]
        thid で指定するスレッドを削除します。
        それにともない、スタック領域とスレッド管理領域を解放します。
        対象のスレッドは、DORMANT 状態でなければなりません。
        自スレッドが DORMANT 状態であることはありえないので、自スレッドを
        対象スレッドにすることはできません(KE_NOT_DORMANTエラーになります)
        。
        自スレッドを削除するには、ExitDeleteThread()を使います。
        

=========================================================================
ExitThread                                                         [関数]
=========================================================================
                                                          自スレッド終了
[形式]
        int ExitThread();
        
[引数]
        なし
        
[返り値]
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだ
				しだった
        
[解説]
        自スレッドを正常終了させ、DORMANT 状態へと移行させます。
        ExitThread()は、発行元のコンテキストに戻らないサービスコールです。
        
        終了するスレッドが獲得した資源(メモリ、セマフォ等)を自動的に開放
        するということはありません。
        
        終了したスレッドを StartThread() で再起動すると、スレッドの優先度
        などのスレッド管理領域に含まれている情報は再設定されます。
        終了時のものを継承することはありません。
        

=========================================================================
GetThreadId                                                        [関数]
=========================================================================
                                              自スレッドのスレッドID参照
[形式]
        int GetThreadId();
        
[引数]
        なし
        
[返り値]
        正(>0)			スレッドのID
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだし				    だった
        
[解説]
        自スレッドのIDを得ます。
        

=========================================================================
ReferThreadStatus / iReferThreadStatus                             [関数]
=========================================================================
                                                        スレッド状態参照
[形式]
        int ReferThreadStatus( int thid, struct ThreadInfo *info );
        int iReferThreadStatus( int thid, struct ThreadInfo *info );
        
[引数]
        thid	参照するスレッドIDを指定します。
        		TH_SELF(=0)で、自スレッドを指定できます。
        info	スレッドの状態を受け取る構造体変数へのポインタを指定します。
        	以下のメンバがあります。
        	u_int    attr;
        	u_int    option;
        	int      status;
        	void     *entry;
        	void     *stack;
        	int      stackSize;
        	int      initPriority;
        	int      currentPriority;
        	int      waitType;
        	int      waitId;
        	int      wakeupCount;
        各メンバの内容は以下の通りです。
        	attr	CreateThread()で設定されたスレッド属性
        	option	CreateThread()で設定された付加情報。
        	status	スレッドの状態を以下のビットの合成であらわします。
        		0x01	THS_RUN	RUN状態
        		0x02	THS_READY	READY状態
        		0x04	THS_WAIT	WAIT状態
        		0x08	THS_SUSPEND	SUSEND状態
        		0x0c	THS_WAITSUSPEND	WAIT-SUSPEND状態
        		0x10	THS_DORMANT	DORMANT状態
        	entry		CreateThread()で設定されたエントリアドレス
        	stackCreate	Thread()実行時にカーネルが確保したスタック
				エリアの先頭アドレス
        	stackSize	CreateThread()で設定されたスタックサイズ。
        	initPriority	CreateThread()で設定されたスレッド起動時
        			(StartThread())の優先度。
        	currentPriority	現在の優先度
        	waitType	スレッドが WAIT状態の時、どのような待ち状態
				であるかを示します。
        			TSW_SLEEP	SleepThread()による待ち状態
        			TSW_DELAY	DelayThread()による待ち状態
        			TSW_SEMA	セマフォの待ち状態
        			TSW_EVENTFLAG	イベントフラグの待ち状態
        			TSW_MBX	メッセージボックスの待ち状態
        			TSW_VPL	可変長メモリプール獲得の待ち状態
        			TSW_FPL	固定長メモリブロック獲得の待ち状態
        	waitId		上記 waitType の待ち対象の ID(イベントフラ
				グのIDなど)
        	wakeupCount	未処理の WakeupThread()の回数
        
[返り値]
        KE_OK			正常
        KE_UNKNOWN_THID		対象スレッドが存在しない
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだ
				しだった
        
[解説]
        スレッドの状態を参照します。このサービスコールは主にデバッグのた
        めに用意されています。デバッグ以外の目的で頻繁に使用する必要はな
        いと思います。
        

=========================================================================
ReleaseWaitThread / iReleaseWaitThread                             [関数]
=========================================================================
                          他スレッドのWAIT状態の強制解除、実装済、未テスト
[形式]
        int ReleaseWaitThread( int thid );
        int iReleaseWaitThread( int thid );
        
[引数]
        thid	WAIT状態を強制解除するスレッドのスレッドIDを指定します。
        
[返り値]
        KE_OK			正常
        KE_UNKNOWN_THID		対象スレッドが存在しない
        KE_NOT_WAIT		対象のスレッドはWAIT状態ではなかった
        KE_ILLEGAL_THID		対象スレッドは自スレッド だった
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだ
				しだった
        
[解説]
        thid で指定されたスレッドがWAIT状態にある場合にはそれを強制的に解
        除します。
        解除されたスレッドは、WAIT状態に入ったサービスコール（SleepThread
        (), WaitEventFlag(), WaitSEma() 等）から戻り、エラーコード KE_REL
        EASE_WAIT を受け取ります。
        
        ReleaseWaitThread()では、WAIT状態解除要求のキューイングは行いませ
        ん。
        すなわち、thid で指定されたスレッドが既にWAIT状態であればそのWAIT
        状態を解除しますが、対象スレッドがWAIT状態でなければ発行元にエラ
        ー KE_NOT_WAITがかえります。
        
        ReleaseWaitThread()では、SUSPEND状態の解除は行いません。
        二重待ち状態(WAIT-SUSPEND)のスレッドを対象としてReleaseWaitThread
        ()を発行すると、対象スレッドは SUSPEND状態になります。

=========================================================================
RotateThreadReadyQueue / iRotateThreadReadyQueue                   [関数]
=========================================================================
                                                スレッドレディキュー回転
[形式]
        int RotateThreadReadyQueue( int priority );
        int iRotateThreadReadyQueue( int priority );
        
[引数]
        priority		キュー回転の対象となる優先度を指定します。
        
[返り値]
        KE_OK			正常
        KE_ILLEGAL_PRIORITY	優先度の指定が不正
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだ
				しだった
        
[解説]
        レディキューの中で priority で指定された優先度の部分を回転します。
        指定された優先度のレディキューの先頭につながれているスレッドをレ
        ディキューの最後につなぎ替え、同一優先度のスレッドの実行を切り替
        えます。
        アプリケーションプログラムはこのサービスコールを一定時間間隔で発
        行することにより、ラウンドロビンスケジューリングを実現することが
        可能です。
        
        スレッド部から発行されるRotateReadyQueue()では、priority に TPRI_
        RUN(=0)を指定することにより、自スレッドのと同じ優先度のレディキュ
        ーを回転させることができます。
        
        RotateReadyQueue()の priority に TPRI_RUN または 自スレッドの優先
        度を指定した場合には、自スレッドがそのレディキューの最後尾に回る
        ことになります。すなわち自ら実行権を放棄するために、 RotateRadyQu
        eue() を発行することができます。
        なおこのサービスコールの説明における「レディキュー」は、RUN状態の
        スレッドも含んだものと考えます。
        
        指定した優先度のレディキューにスレッドが無い場合は何も起きずエラ
        ーにもなりません。
        
        タイマハンドラなどのスレッド独立部から iRotateReadyQueue(TPRI_RUN)
        を発行することも可能で、その場合には、その時実行中のスレッドを含
        むレディキューまたはレディキュー中の最高優先度のスレッドを含むレ
        ディキューを回転させます。通常この二つは一致していますが、スレッ
        ドのディスパッチが遅延されている状態においては、一致しない場合が
        あります。
        この場合、最高優先度のスレッドを含むレディキューを回転させます。
        

=========================================================================
StartThread                                                        [関数]
=========================================================================
                                                            スレッド起動
[形式]
        int StartThread( int thid, u_long arg );
        
[引数]
        thid	起動するスレッドの ID を指定します。
        arg	スレッドのエントリ関数の引数を指定します。
        
[返り値]
        KE_OK			正常
        KE_UNKNOWN_THID		対象スレッドが存在しない
        KE_ILLEGAL_THID		TH_SELFは指定できない
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだ
				しだった
        KE_NOT_DORMANT		対象のスレッドはDORMANT状態ではなかった
        
[解説]
        thid で指定するスレッドの実行を開始し、READY状態にします。
        arg によって、スレッドに引数を渡すことが出来ます。
        対象スレッドの優先度は、生成時に指定した initPriorityの値になりま
        す。
        このサービスコールは起動要求のキューイングは行わないません。すな
        わち、対象スレッドが DORMANT状態でない場合は このサービスコールは
        無視され、発行スレッドにKE_NOT_DORMANTエラーが返ります。
        

=========================================================================
StartThreadArgs                                                    [関数]
=========================================================================
                                                            スレッド起動
[形式]
        int StartThreadArgs( int thid, int args, void *argp );
        
[引数]
        thid	起動するスレッドの ID を指定します。
        args	スレッドのエントリ関数の引数ブロックのバイト数を指定します
        argp	スレッドのエントリ関数の引数ブロックへのポインタを指定しま
		す。
        
[返り値]
        KE_OK			正常
        KE_UNKNOWN_THID		対象スレッドが存在しない
        KE_ILLEGAL_THID		TH_SELFは指定できない
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだ
				しだった
        KE_NOT_DORMANT		対象のスレッドはDORMANT状態ではなかった
        
[解説]
        thid で指定するスレッドの実行を開始し、READY状態にします。
        args, argp によって指定された引数ブロックは、スレッドのスタック上
        にコピーされ、args はそのままスレッドのエントリ関数の第一引数に渡
        され、エントリ関数の第二引数には、スタック上にコピーされた引数ブ
        ロックのアドレスが渡されます。
        対象スレッドの優先度は、生成時に指定した initPriorityの値になりま
        す。
        このサービスコールは起動要求のキューイングは行わないません。すな
        わち、対象スレッドが DORMANT状態でない場合は このサービスコールは
        無視され、発行スレッドに KE_NOT_DORMANTエラーが返ります。

=========================================================================
TerminateThread / iTerminateThread                                 [関数]
=========================================================================
                                      他スレッド強制終了 実装済、未テスト
[形式]
        int TerminateThread( int thid );
        int iTerminateThread( int thid );
        
[引数]
        thid	強制終了するスレッドのスレッドID
        
[返り値]
        KE_OK			正常
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだ
				しだった
        KE_UNKNOWN_THID		対象スレッドが存在しない。
        KE_ILLEGAL_THID		対象スレッドは自スレッド だった
        KE_DORMANT		対象のスレッドはDORMANT状態だった
        
[解説]
        thid で指定した他スレッドを強制的に終了させ、DORMANT 状態へと移行
        させます。
        対象スレッドが WAIT状態（SUSPEND状態を含む）にあった場合でも、対
        象スレッドは待ち解除となって DORMANT 状態に移行します。
        また、対象スレッドがなんらかの待ち行列（セマフォ待ち等）につなが
        れていた場合は、その待ち行列から削除されます。
        thidで自スレッドを指定することは許されず、エラーになります。
        
        終了するスレッドが獲得した資源(メモリ、セマフォ等)を自動的に開放
        するということはありません。
        終了させたスレッドを StartThread() で再起動すると、スレッドの優先
        度などのスレッド管理領域に含まれている情報は再設定されます。
        終了時のものを継承することはありません。
        

 4 スレッド直接同期関数
========================


=========================================================================
CancelWakeupThread / iCancelWakeupThread                           [関数]
=========================================================================
                                               スレッドの起床要求を無効化
[形式]
        int CancelWakeupThread( int thid );
        int iCancelWakeupThread( int thid );
        
[引数]
        thid	起床要求を無効化するスレッドの ID を指定します。
        	TH_SELF(=0)で、自スレッドを指定できます。
        
[返り値]
        正(>=0)			起床要求回数
        KE_UNKNOWN_THID		対象スレッドが存在しない
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだ
				しだった
        
[解説]
        thid で示されたスレッドの起床要求のカウントを読み出し、起床要求を
        すべて無効にします。
        

=========================================================================
ResumeThread / iResumeThread                                       [関数]
=========================================================================
                                       SUSPEND状態のスレッドの再開 未実装
[形式]
        int ResumeThread( int thid );
        int iResumeThread( int thid );
        
[引数]
        thid	SUSPEND状態を解除するスレッドのスレッドIDを指定します。
        
[返り値]
        KE_OK			正常
        KE_UNKNOWN_THID		対象スレッドが存在しない
        KE_NOT_SUSPEND		対象のスレッドはSUSPEND状態ではなかった
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだ
				しだった
        
[解説]
        thid 定されたスレッドの SUSPEND状態を解除します。
        

=========================================================================
SleepThread                                                        [関数]
=========================================================================
                                          自スレッドを起床待ち状態へ移行
[形式]
        int SleepThread();
        
[引数]
        なし
        
[返り値]
        KE_OK			正常
        KE_RELEASE_WAIT		ReleaseWait によって状態が解除された。
        KE_CAN_NOT_WAIT		ディスパッチ禁止状態で待ち状態に入ろうとした
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだ
				しだった
        
[解説]
        自スレッドを起床待ち状態(WAIT状態)にします。
        
        起床待ちに入ったスレッドは、WakeupThread() または、ReleaseWaitThr
        ead() によって WAIT状態から戻ります。
        
        SleepThread() を発行したとき、既に他スレッドによってWakeupThread()
         が発行されていると、起床要求回数をカウントダウンするのみで WAIT
        状態に入ること無く SleepThread() から戻ります。詳しくは WakeupThr
        ead() の項を参照してください。
        
[備考]
        SleepThread() を割り込み禁止状態で呼ばないでください。
        これは本来エラーになるはずですが、現状は警告をプリントして割り込
        み禁止状態が一旦解除されて他のスレッドに切り替わってしまい、自ス
        レッドがふたたび RUN状態に復帰したときに割り込み禁止状態にもどる
        という動作をします。

=========================================================================
SuspendThread / iSuspendThread                                     [関数]
=========================================================================
                                     他スレッドをSUSPEND状態へ移行 未実装
[形式]
        int SuspendThread( int thid );
        int iSuspendThread( int thid );
        
[引数]
        thid 	SUSPEND状態へ移行させるスレッドのスレッドIDを指定します。
        	自スレッドは指定できません。
        
[返り値]
        KE_OK			正常
        KE_UNKNOWN_THID		対象スレッドが存在しない
        KE_ILLEGAL_THID		対象スレッドは自スレッドだった
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだし				    だった
        
[解説]
        thid で指定されたスレッドを SUSPEND状態に移し、スレッドの実行を中
        断させます。
        SUSPEND状態は、ResumeThread() によって解除されます。
        
        SuspendThread() の対象スレッドが既にWAIT状態にあった場合は、WAIT
        状態と SUSPEND状態が複合した、WAIT-SUSPEND状態になります。その後、
        このスレッドの WAIT解除の条件が満たされた場合は SUSPEND状態に移行
        します。
        一方、このWAIT-SUSPEND状態のスレッドに対して ResumeThread()が発行
        された場合は以前とおなじWAIT状態に戻ります。
        
        SUSPEND状態は、他スレッドの発行したサービスコールによる中断状態を
        意味するものなので、本サービスコールで自スレッドを指定することは
        できません。
        
        あるスレッドに対して複数回の SuspendThread() が発行された場合、2
        度目以降のSuspendThread() はエラーとなります。
        

=========================================================================
WakeupThread / iWakeupThread                                       [関数]
=========================================================================
                                                         他スレッドの起床
[形式]
        int WakeupThread( int thid );
        int iWakeupThread( int thid );
        
[引数]
        thid	起床するスレッドの ID を指定します。
        
[返り値]
        KE_OK			正常
        KE_UNKNOWN_THID		対象スレッドが存在しない
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだし				    だった
        
[解説]
        thid で指定したスレッドの起床待ち状態を解除します。
        対象スレッドが WAIT状態になっていない場合すなわちSleepThread()を
        実行していない場合、WakeupThread() による起床要求の回数がカウント
        アップされます。
        
        対象スレッドが SleepThread() を発行しても、起床要求の回数分発行す
        るまでは WAIT状態に移行することは無くなります。
        
[備考]
        現状では、WakeupThread() を割り込み禁止状態で呼んだ場合、起床され
        たスレッドが自スレッドよりも優先順位が高いと割り込み禁止状態が解
        除されてそのスレッドに切り替わってしまい、自スレッドがふたたび RU
        N状態に復帰したときに割り込み禁止状態にもどるという動作をします。
        この動作はいずれ変更され、割り込み禁止状態が解除されるまでスレッ
        ドの切り替えが遅らされるようになる予定です。
        挙動が変わりますので今は割り込み禁止状態で呼ばないことをおすすめ
        します。
        

 5 セマフォによる排他制御関数
==============================


=========================================================================
CreateSema                                                         [関数]
=========================================================================
                                                             セマフォ生成
[形式]
        int CreateSema( struct SemaParam *param );
        
[引数]
        param	生成するセマフォの設定情報をもつ構造体変数へのポインタを指
        定します。
        	以下のメンバがあります。
        	u_int	attr;
        	int	initCount;
        	int	maxCount;
        	u_int	option;
        	各メンバの内容は以下の通りです。
        	attr	セマフォの属性を指定します。以下のどちらかを指定し
			ます。
        		SA_THFIFO   待ちスレッドのキューイングはFIFOで行う
        		SA_THPRI    待ちスレッドのキューイングはスレッドの					    優先度で行う。
        	initCount	セマフォの初期値
        	maxCount	セマフォの最大値
        	option		セマフォに関する付加情報。この値は、
				ReferSemaStatus()で参照できます。
        			マルチスレッドマネージャはこの値を関知しま
				せん。
        
[返り値]
        正(>0)			セマフォのID
        KE_NO_MEMORY		メモリ不足
        KE_ILLEGAL_ATTR		attr の指定が不正
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだし				    だった
        
[解説]
        セマフォを生成します。戻り値にセマフォのIDが返ってきます。
        

=========================================================================
DeleteSema                                                         [関数]
=========================================================================
                                                             セマフォ削除
[形式]
        int DeleteSema( int semid );
        
[引数]
        semid	削除するセマフォIDを指定します。
        
[返り値]
        KE_OK			正常
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだしだ
        った
        KE_UNKNOWN_SEMID	対象セマフォが存在しない
        
[解説]
        semid で示したセマフォを削除します。
        セマフォの待ちキューに登録されていたスレッドにはエラー(KE_WAIT_DE
        LETE)が返されます。
        

=========================================================================
ReferSemaStatus / iReferSemaStatus                                 [関数]
=========================================================================
                                                         セマフォ状態参照
[形式]
        int ReferSemaStatus( int semid, struct SemaInfo *info );
        int iReferSemaStatus( int semid, struct SemaInfo *info );
        
[引数]
        semid	参照するセマフォID
        info	セマフォの状態を受け取る構造体変数へのポインタを指定します。
        	以下のメンバがあります。
        	u_int	attr;
        	u_int	option;
        	int	initCount;
        	int	currentCount;
        	int	maxCount;
        	int	numWaitThreads;
        	各メンバの内容は以下の通りです。
        	attr		CreateSema()で設定されたセマフォ属性
        	option		CreateSema()で設定された付加情報
        	initCount	CreateSema()で設定されたセマフォの初期値
        	currentCount	セマフォの現在値
        	maxCount	CreateSema()で設定されたセマフォの最大値
        	numWaitThreads 	セマフォ待ちをしているスレッド数
        
[返り値]
        KE_OK			正常
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだ
				しだった
        KE_UNKNOWN_SEMID	対象セマフォが存在しない
        
[解説]
        セマフォの状態を参照します。
        

=========================================================================
SignalSema / iSignalSema                                           [関数]
=========================================================================
                                                         セマフォ資源返却
[形式]
        int SignalSema( int semid );
        int iSignalSema( int semid );
        
[引数]
        semid	資源を返却するセマフォID
        
[返り値]
        KE_OK			正常
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだ
				しだった
        KE_UNKNOWN_SEMID	対象セマフォが存在しない
        KE_SEMA_OVF		セマフォカウンタが最大値に達して更新できな
				い
        
[解説]
        semid で示されたセマフォに対して、資源を一つ返却する操作を行いま
        す。
        具体的には、対象セマフォに対して既に待っているスレッドがあれば、
        待ち行列の先頭のスレッドを READY状態に移します。この場合そのセマ
        フォのカウント値は不変です。一方、対象セマフォにたいして待ってい
        るスレッドがなければ、そのセマフォのカウント値を１つ増やします。
        ただし、カウンタが既に最大値に達しているときは、カウント値は変ら
        ずにエラー(KE_SEMA_OVF)になります。
        
[備考]
        現状では、SignalSema() を割り込み禁止状態で呼んだ場合、 WAIT 状態
        を解除されたスレッドが自スレッドよりも優先順位が高いと割り込み禁
        止状態が解除されてそのスレッドに切り替わってしまい、自スレッドが
        ふたたび RUN状態に復帰したときに割り込み禁止状態にもどるという動
        作をします。
        この動作はいずれ変更され、割り込み禁止状態が解除されるまでスレッ
        ドの切り替えが遅らされるようになる予定です。
        挙動が変わりますので今は割り込み禁止状態で呼ばないことをおすすめ
        します。
        

=========================================================================
WaitSema / PollSema                                                [関数]
=========================================================================
                                                         セマフォ資源獲得
[形式]
        int WaitSema( int semid );
        int PollSema( int semid );
        
[引数]
        semid	資源を獲得するセマフォID
        
[返り値]
        KE_OK			正常
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだ
				しだった
        KE_UNKNOWN_SEMID	対象セマフォが存在しない
        KE_SEMA_ZERO		セマフォの資源が獲得できない
        KE_RELEASE_WAIT		WAIT状態は強制解除された。
        KE_CAN_NOT_WAIT		ディスパッチ禁止状態で待ち状態に入ろうとした
        KE_WAIT_DELETE		WAIT対象のオブジェクトが削除された。
        
[解説]
        semid で示したセマフォから資源を一つ獲得する操作を行います。
        具体的には、対象セマフォのカウント値が 1 以上の場合セマフォのカウ
        ント値を１減らします。この場合本サービスコールを発行したスレッド
        はWAIT状態に入らず、実行を継続します。一方、対象セマフォのカウン
        ト値が 0 の場合、本サービスコールを発行したスレッドはWAIT状態に入
        り、そのセマフォの待ちキューにつながれます。
        
        PollSema サービスコールは、WaitSema から、WAIT状態にはいる機能を
        取り除いたサービスコールです。WaitSema と異なり対象セマフォのカウ
        ント値が 0 の場合、エラー KE_SEMA_ZERO で戻ります。
        
[備考]
        WaitSema() を割り込み禁止状態で呼ばないでください。
        これは本来エラーになるはずですが、現状は警告をプリントして割り込
        み禁止状態が一旦解除されて他のスレッドに切り替わってしまい、自ス
        レッドがふたたび RUN状態に復帰したときに割り込み禁止状態にもどる
        という動作をします。
        

 6 イベントフラグによる同期管理関数
====================================


=========================================================================
ClearEventFlag / iClearEventFlag                                   [関数]
=========================================================================
                                                   イベントフラグのクリア
[形式]
        int ClearEventFlag( int evfid, u_long bitpattern );
        int iClearEventFlag( int evfid, u_long bitpattern );
        
[引数]
        evfid	    操作するイベントフラグIDを指定します。
        bitpattern  bitpattern 中の値が 0 の ビットに該当するイベントフラ
        	    グ値をクリアします。すなわち、イベントフラグ値と
		     bitpattern の論理積を新たなイベントフラグ値とします。
        
[返り値]
        KE_OK			正常
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだ
				しだった
        KE_UNKNOWN_EVFID	対象イベントフラグが存在しない
        
[解説]
        evfid でしめすイベントフラグのビットのクリアを行います。
        このサービスコールによってイベント待ちのスレッドのWAIT状態が解除
        されることはありません。
        

=========================================================================
CreateEventFlag                                                    [関数]
=========================================================================
                                                       イベントフラグ生成
[形式]
        int CreateEventFlag( struct EventFlagParam *param );
        
[引数]
        param	生成するスレッドの設定情報をもつ構造体変数へのポインタを指
        	定します。
        	以下のメンバがあります。
        	int	attr;
        	int	initPattern;
        	u_int	option;
        	各メンバの内容は以下の通りです。
        	attr 	イベントフラグの属性を指定します。以下のどちらかを
			指定します。
        		EA_SINGLE	複数スレッドの待ちを許さない
        		EA_MULTI	複数スレッドの待ちを許す
        	initPattern		イベントフラグの初期値
        	option			イベントフラグに関する付加情報。
			この値は、ReferEventFlagStatus()で参照できます。
        		マルチスレッドマネージャはこの値を関知しません。
        
[返り値]
        正(>0)			イベントフラグのID
        KE_NO_MEMORY		メモリ不足
        KE_ILLEGAL_ATTR		attr の指定が不正
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだ
				しだった
        
[解説]
        イベントフラグを生成し、イベントフラグの初期値を設定します。
        戻り値として、生成されたイベントフラグのIDを返します。
        

=========================================================================
DeleteEventFlag                                                    [関数]
=========================================================================
                                                       イベントフラグ削除
[形式]
        int DeleteEventFlag( int evfid );
        
[引数]
        evfid	削除するイベントフラグIDを指定します。
        
[返り値]
        KE_OK			正常
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだ
				しだった
        KE_UNKNOWN_EVFID	対象イベントフラグが存在しない
        
[解説]
        evfidで指定したイベントフラグを削除します。
        対象イベントフラグに対して条件成立待ちをしているスレッドにはエラ
        ー(KE_WAIT_DELETE)が返されます。
        

=========================================================================
ReferEventFlagStatus / iReferEventFlagStatus                       [関数]
=========================================================================
                                                   イベントフラグ状態参照
[形式]
        int ReferEventFlagStatus( int evfid, struct EventFlagInfo *info );
        int iReferEventFlagStatus( int evfid, struct EventFlagInfo *info )
        ;
        
[引数]
        evfid	参照するイベントフラグID
        info	イベントフラグの状態を受け取る構造体変数へのポインタを指定
		します。
        	以下のメンバがあります。
        	u_int	attr;
        	u_int	option;
        	u_int	initPattern;
        	u_int	currentPattern;
        	int	numWaitThreads;
        	各メンバの内容は以下の通りです。
        	attr	CreateEventFlag()で設定されたイベントフラグ属性
        	option		CreateEventFlag()で設定された付加情報
        	initPattern	イベントフラグの初期値
        	currentPattern	イベントフラグの現在値
        	numWaitThreads イベントフラグ待ちをしているスレッド数
        
[返り値]
        KE_OK			正常
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだし				    だった
        KE_UNKNOWN_EVFID	対象イベントフラグが存在しない
        
[解説]
        イベントフラグの状態を参照します。
        

=========================================================================
SetEventFlag / iSetEventFlag                                       [関数]
=========================================================================
                                                   イベントフラグのセット
[形式]
        int SetEventFlag( int evfid, u_long bitpattern );
        int iSetEventFlag( int evfid, u_long bitpattern );
        
[引数]
        evfid	操作するイベントフラグIDを指定します。
        bitpattern	bitpattern で示すビットを イベントフラグ値にセット
			します。
        すなわち、イベントフラグ値と bitpattern の論理和を新たなイベント
        フラグ値とします。
        
[返り値]
        KE_OK			正常
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだ
				しだった
        KE_UNKNOWN_EVFID	対象イベントフラグが存在しない
        
[解説]
        evfid でしめすイベントフラグのビットのセットを行います。
        新しいイベントフラグ値によって、待ち条件を満たしたWAIT状態のスレ
        ッドは WAIT状態を解除されます。
        
[備考]
        現状では、SetEventFlag() を割り込み禁止状態で呼んだ場合、 WAIT 状
        態を解除されたスレッドが自スレッドよりも優先順位が高いと割り込み
        禁止状態が解除されてそのスレッドに切り替わってしまい、自スレッド
        がふたたび RUN状態に復帰したときに割り込み禁止状態にもどるという
        動作をします。
        この動作はいずれ変更され、割り込み禁止状態が解除されるまでスレッ
        ドの切り替えが遅らされるようになる予定です。
        挙動が変わりますので今は割り込み禁止状態で呼ばないことをおすすめ
        します。
        

=========================================================================
WaitEventFlag / PollEventFlag                                      [関数]
=========================================================================
                                                       イベントフラグ待ち
[形式]
        int WaitEventFlag( int evfid, u_long bitpattern, int waitmode, u_
        long *resultpat );
        int PollEventFlag( int evfid, u_long bitpattern, int waitmode, u_
        long *resultpat );
        
[引数]
        evfid        操作するイベントフラグIDを指定します。
        bitpattern   イベントフラグとの比較値を指定します。
        waitmode     待ちモードを指定します。以下のどちらかを指定します。
                       EW_AND    AND待ち
                       EW_OR      OR待ち
                       また、オプションで、以下の指定を 論理和で追加できま
        	       す。
                       EW_CLEAR	待ち条件成立後、クリア
        resultpat    待ち解除時のイベントフラグ値を受け取る変数へのポインタ        
[返り値]
        KE_OK			正常
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだ
				しだった
        KE_UNKNOWN_EVFID	対象イベントフラグが存在しない
        KE_CAN_NOT_WAIT		ディスパッチ禁止状態で待ち状態に入ろうとした
        KE_WAIT_DELETE		WAIT対象のオブジェクトが削除された。
        KE_RELEASE_WAIT		WAIT状態は強制解除された。
        
[解説]
        WaitEventFlag() は、waitmode で示される待ち解除の条件にしたがって、
        evfid で示されるイベントフラグがセットされるのを待つサービスコー
        ルです。
        evfid で示されるイベントフラグが、既に waitmode で示される待ち解
        除条件を満たしている場合には、発行スレッドは待ち状態に入らずに実
        行を続けます。
        
        waitmode に EW_AND を指定した場合、bitpattern で示されるすべての
        ビットが 1 になるまで待ちます。
        waitmode に EW_OR を指定した場合、bitpattern で示されるいずれかの
        ビットが 1 になるまで待ちます。
        waitmode に EW_CLEAR が追加指定されている場合、解除条件が成立して
        このスレッドが待ち解除になったときに、イベントフラグのすべてのビ
        ットは 0 クリアされます。
        
        resultpat には、待ち解除条件成立直後のイベントフラグ値(EW_CLEAR指
        定によるクリアの前の値)が返されます。
        
        PollEventFlag() は、WaitEventFlag() から待ち状態に入る機能を取り
        除いたサービスコールです。WaitEventFlag() とは異なり待ち解除条件
        が成立していない場合は直ちにエラー KE_EVF_COND で戻ります。この場
        合 EW_CLEAR指定は無視されます。
        
        既に待ちスレッドの存在する EA_SINGLE属性のイベントフラグに対して
        別のスレッドが WaitEventFlag(), PollEventFlag() を実行することは
        できません。
        この場合あとから WaitEventFlag(), PollEventFlag() を実行したスレ
        ッドへは直ちにエラーで戻ります。
        
        EA_MULTI属性のイベントフラグに対して複数のスレッドが待ちに入る場
        合はスレッドの待ち行列が作られます。この場合、一回の SetEventFlag
        ()で複数のスレッドが待ち解除となることがあります。
        
        スレッドの待ち行列の順番は、先に待ちに入ったものが先頭になり待ち
        に入った順に並びます。
        待ち行列中に EW_CLEAR指定のスレッドがあり、そのスレッドの待ち解除
        条件が成立したときは、待ち解除と同時にイベントフラグがクリアされ
        ます。
        EW_CLEAR指定を行っていたスレッドよりも後ろにあったスレッドはクリ
        アされた後のイベントフラグを見ることになるため、待ち解除になりま
        せん。
        
[備考]
        WaitEventFlag() を割り込み禁止状態で呼ばないでください。
        これは本来エラーになるはずですが、現状は警告をプリントして割り込
        み禁止状態が一旦解除されて他のスレッドに切り替わってしまい、自ス
        レッドがふたたび RUN状態に復帰したときに割り込み禁止状態にもどる
        という動作をします。
        

 7 メッセージボックスによる通信関数
====================================


=========================================================================
CreateMbx                                                          [関数]
=========================================================================
                                  メッセージボックス生成 実装済、未テスト
[形式]
        int CreateMbx( struct MbxParam *param );
        
[引数]
        param   生成するメッセージボックスの設定情報をもつ構造体変数への
        	ポインタを指定します。
                以下のメンバがあります。
                int      attr;
                u_int   option;
                各メンバの内容は以下の通りです。
                attr    メッセージボックスの属性を指定します。
                        以下のどちらかを指定します。
                         MBA_THFIFO   待ちスレッドのキューイングはFIFOで
        			      行う
                         MBA_THPRI    待ちスレッドのキューイングはスレッ
        			      ドの優先度で行う
                         MBA_MSFIFO   メッセージののキューイングはFIFOで
        			      行う
                         MBA_MSPRI    メッセージののキューイングはメッセ
        			      ージの優先度で行う
                option  メッセージボックスに関する付加情報。
			この値は、ReferMbxStatus()で参照できます。
                        マルチスレッドマネージャはこの値を関知しません。
        
[返り値]
        正(>0)			メッセージボックスのID
        KE_NO_MEMORY		メモリ不足
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだ
				しだった
        KE_ILLEGAL_ATTR		attr の指定が不正
        
[解説]
        メッセージボックスを生成します。
        戻り値に、生成されたメッセージボックスのIDを返します。
        

=========================================================================
DeleteMbx                                                          [関数]
=========================================================================
                                  メッセージボックス削除 実装済、未テスト
[形式]
        int DeleteMbx( int mbxid );
        
[引数]
        mbxid	削除するメッセージボックスのIDを指定します。
        
[返り値]
        KE_OK			正常
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだ
				しだった
        KE_UNKNOWN_MBXID	対象メッセージボックスが存在しない
        
[解説]
        mbxidで示めしたメッセージボックスを削除します。
        
        対象メッセージボックスにおいてメッセージを待っているスレッドがあ
        った場合にも、本サービスコールは正常終了し、待ち状態にあったスレ
        ッドには、エラー(KE_WAIT_DELETE)が返されます。
        
        また、対象メッセージボックスの中にメッセージが残っている場合でも、
        エラーとはならずに、メッセージボックスの削除が行われ、中にあった
        メッセージは放置されたままになります。

=========================================================================
ReceiveMbx / PollMbx                                               [関数]
=========================================================================
                              メッセージボックスから受信 実装済、未テスト
[形式]
        int ReceiveMbx( struct MsgPacket **recvmsg, int mbxid );
        int PollMbx( struct MsgPacket **recvmsg, int mbxid );
        
[引数]
        recvmsg   受信メッセージパケットの先頭アドレスを受け取る変数への
		  ポインタを指定します。
        mbxid     受信メッセージボックスを指定します。
        
[返り値]
        KE_OK			正常
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだ
				しだった
        KE_UNKNOWN_MBXID	対象メッセージボックスが存在しない
        KE_RELEASE_WAIT		WAIT状態は強制解除された。
        KE_CAN_NOT_WAIT		ディスパッチ禁止状態で待ち状態に入ろうとした
        KE_WAIT_DELETE		WAIT対象のオブジェクトが削除された。
        
[解説]
        ReceiveMbx は、mbxid で示された対象メッセージボックスからメッセー
        ジを受信します。
        対象メッセージボックスにまだメッセージが送信されていない場合（メ
        ッセージボックスが空の場合）には、本サービスコールを発行したスレ
        ッドは WAIT状態となり、メッセージボックスのメッセージ到着待ち行列
        につながれます。
        一方、対象メッセージボックスに既にメッセージが入っている場合には、
        先頭にあるメッセージを一つ取り出して、それをリターンパラメータ re
        cvmsg に格納して戻ります。
        
        PollMbx は、ReceiveMbxから、待ち行列にはいる機能を取り除いたサー
        ビスコールです。対象メッセージボックスにまだメッセージが送信され
        ていない場合、エラー(KE_MBOX_NOMSG)終了することが ReceiveMbxと異
        なります。
        
[備考]
        ReceiveMbx() を割り込み禁止状態で呼ばないでください。
        これは本来エラーになるはずですが、現状は警告をプリントして割り込
        み禁止状態が一旦解除されて他のスレッドに切り替わってしまい、自ス
        レッドがふたたび RUN状態に復帰したときに割り込み禁止状態にもどる
        という動作をします。
        

=========================================================================
ReferMbxStatus / iReferMbxStatus                                   [関数]
=========================================================================
                              メッセージボックス状態参照	実装済、未テスト
[形式]
        int ReferMbxStatus( int mbxid, struct MbxInfo *info );
        int iReferMbxStatus( int mbxid, struct MbxInfo *info );
        
[引数]
        mbxid	参照するメッセージボックスID
        info	メッセージボックスの状態を受け取る構造体変数へのポインタを			指定します。
        	以下のメンバがあります。
        	u_int	attr;
        	u_int	option;
        	int	numWaitThreads;
        	int	numMessage;
        	struct	MsgPacket *topPacket;
        	各メンバの内容は以下の通りです。
        	attr	CreateMbx()で設定されたメッセージボックス属性
        	option		CreateMbx()で設定された付加情報
        	numWaitThreads	メッセージ待ちをしているスレッド数
        	numMessage	メッセージボックスに残っている受信待メッセー				    ジ数
        	topPacket	先頭の受信待メッセージ
        
[返り値]
        KE_OK			正常
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだし				    だった
        KE_UNKNOWN_MBXID	対象メッセージボックスが存在しない
        
[解説]
        メッセージボックスの状態を参照します。
        

=========================================================================
SendMbx / iSendMbx                                                 [関数]
=========================================================================
                                メッセージボックスへ送信 実装済、未テスト
[形式]
        int SendMbx( int mbxid, struct MsgPacket *sendmsg );
        int iSendMbx( int mbxid, struct MsgPacket *sendmsg );
        
[引数]
        mbxid      送信先メッセージボックスを指定します。
        sendmsg    送信するメッセージパケットの先頭アドレスを指定します。
        
[返り値]
        KE_OK			正常
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだ
				しだった
        KE_UNKNOWN_MBXID	対象メッセージボックスが存在しない
        
[解説]
        mbxid で示された対象メッセージボックスに sendmsg を先頭アドレスと
        するメッセージパケットを送信します。メッセージパケットの内容はコ
        ピーされず、受信時には先頭アドレス（sendmsgの値）のみが渡されます。
        
        対象メッセージボックスで既にメッセージを待っているスレッドがあっ
        た場合には、待ち行列の先頭のスレッドのWAIT状態が解除され、SendMbx
         で指定した sendmsg がそのスレッドに送信されて、下記 ReceiveMbx
        の recvmsgのリターンパラメータとなります。
        
        一方、対象メッセージボックスでメッセージを待っているスレッドがな
        ければ、送信されたメッセージはメッセージボックスの中のメッセージ
        キューに入れられます。
        どちらの場合にも、SendMbxを発行したスレッドがWAIT状態になることは
        ありません。
        
        メッセージパケットは、システム規定のメッセージヘッダとそれに連続
        してつづくアプリケーションプログラムがデータを格納するメッセージ
        ボディ部からなります。
        
        アプリケーションプログラムは必要に応じてメッセージヘッダ部の msgP
        riority を設定することができます。メッセージヘッダ部のその他の部
        分をアプリケーションプログラムが操作する必要はありません。
        
        マルチスレッドマネージャは、メッセージボディ部をまったく関知しま
        せん。
        メッセージボディ部をどのようなサイズにするか、そのサイズをどのよ
        うにスレッド間でやりとりするか（暗黙にサイズを規定するか、ボディ
        部にサイズを示す情報をのせるか等）はアプリケーションプログラムに
        まかされています。
        
        また、メッセージパケットを格納するメモリの管理もアプリケーション
        プログラムにまかされています。アプリケーションプログラムの送信ス
        レッドは、マルチスレッドマネージャが提供するメモリプール管理機能
        を使用してメモリを確保したりプログラム中に宣言した配列変数からメ
        モリを確保して、メッセージパケットのデータを格納し送信します。
        
        受信スレッドは受信したメッセージパケットのデータを処理したあと、
        メモリプール管理機能を使用してメモリを返却したり配列変数に返却し
        たりします。
        送信スレッドと受信スレッドで一貫したメモリ管理をすることは、アプ
        リケーションプログラムにまかされています。
        
[備考]
        現状では、SendMbx() を割り込み禁止状態で呼んだ場合、 WAIT 状態を
        解除されたスレッドが自スレッドよりも優先順位が高いと割り込み禁止
        状態が解除されてそのスレッドに切り替わってしまい、自スレッドがふ
        たたび RUN状態に復帰したときに割り込み禁止状態にもどるという動作
        をします。
        この動作はいずれ変更され、割り込み禁止状態が解除されるまでスレッ
        ドの切り替えが遅らされるようになる予定です。
        挙動が変わりますので今は割り込み禁止状態で呼ばないことをおすすめ
        します。

 8 割り込み管理関数
====================


=========================================================================
CpuDisableIntr                                                     [関数]
=========================================================================
                                             割り込みとディスパッチの禁止
[形式]
        int CpuDisableIntr();
        
[引数]
        なし
        
[返り値]
        KE_OK		正常
        KE_CPUDI	既に割り込み禁止だった
        
[解説]
        すべての割り込みとスレッドのディスパッチを禁止します。
        これ以降、CpuEnableIntr() か CpuResumeIntr() が発行されて割り込み
        およびディスパッチが許可されるまで、CpuDisableIntr() を発行したス
        レッドが他のスレッドにプリエンプトされることは無くなります。
        
        割り込み禁止は、CPU本体の割り込み禁止（またはそれに準ずるハード的
        な割り込み禁止）を行い、各割り込み要因個別の割り込み許可／禁止状
        態とは独立に行われます（すなわち、割り込みコントローラの要因別割
        り込みマスクレジスタは変更しません）。
        
        既に 割り込みとディスパッチが禁止された状態で、ふたたびCpuDisable
        Intr() を行うと KE_CPUDIエラーを返します。
        

=========================================================================
CpuEnableIntr                                                      [関数]
=========================================================================
                                             割り込みとディスパッチの許可
[形式]
        int CpuEnableIntr();
        
[引数]
        なし
        
[返り値]
        KE_OK			正常
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだ
				しだった
        
[解説]
        割り込みとディスパッチを許可します。
        

=========================================================================
CpuResumeIntr                                                      [関数]
=========================================================================
                                       割り込みとディスパッチの状態の復帰
[形式]
        int CpuResumeIntr(int oldstat);
        
[引数]
        oldstat	CpuSuspendIntr で取得した前の状態を渡します。
        
[返り値]
        KE_OK	正常
        
[解説]
        割り込みとディスパッチの状態を復帰します。
        CpuSuspendIntr と対にして使います。
        

=========================================================================
CpuSuspendIntr                                                     [関数]
=========================================================================
                                   割り込みとディスパッチの状態保存と禁止
[形式]
        int CpuSuspendIntr(int *oldstat);
        
[引数]
        oldstat	前の状態を返すための変数へのポインタを指定します。
        
[返り値]
        KE_OK		正常
        KE_CPUDI	既に割り込み禁止だった
        
[解説]
        CpuDisableIntr と同様に割り込みとスレッドのディスパッチを禁止しま
        す。
        CpuDisableIntr と異なる点は、禁止操作をする直前の状態を、oldstat
        で指し示す変数に格納する点です。
        
        既に割り込みとディスパッチが禁止された状態で、ふたたびCpuSuspendI
        ntr を行うと KE_CPUDIエラーを返します。この場合でも*oldstat には
        適切な値が設定されます。
        

=========================================================================
DisableIntr                                                        [関数]
=========================================================================
                                         特定の割り込み要因の割り込み禁止
[形式]
        int DisableIntr( int intrcode, int *oldstat );
        
[引数]
        intrcode 割り込み要因を指定します。
        	指定できる割り込み要因は、RegisterIntrHandler()サービス
		コールのintrcode 引数とおなじです。
        oldsta	指定した割り込み要因の変更前の状態を返すための変数への
		ポインタを指定します。
        	割り込みが許可状態であったならば、割り込み要因番号が帰って
		きます。
        	割り込みが禁止状態であったならば、KE_INTRDISABLE が帰ってき
		ます。
        
[返り値]
        KE_OK				正常
        KE_INTRDISABLE			割り込みはすでに禁止状態だった
        KE_ILLEGAL_INTRCODE		割り込み要因番号が不正
        
[解説]
        特定の割り込み要因の割り込みを禁止します。
        

=========================================================================
EnableIntr                                                         [関数]
=========================================================================
                                         特定の割り込み要因の割り込み許可
[形式]
        int EnableIntr( int intrcode );
        
[引数]
        intrcode 割り込み要因を指定します。
        	指定できる割り込み要因については、RegisterIntrHandler
		サービスコールのintrcode引数とおなじです。
        
[返り値]
        KE_OK				正常
        KE_ILLEGAL_INTRCODE		割り込み要因番号が不正
        

=========================================================================
interrupthandler                                                   [関数]
=========================================================================
                                           割り込みハンドラのプロトタイプ
[形式]
        int interrupthandler(void *common);
        
[引数]
        common     RegisterIntrHandler()で指定された common が渡されます。
        
[返り値]
        NEXT_ENABLE		担当割り込み要因を再び割り込み許可にする。
				(=1)
        NEXT_DISABLE		担当割り込み要因を割り込み禁止にする。(=0)
        
[解説]
        割り込みハンドラが呼ばれたとき、担当割り込み要因は一時的に割り込
        み禁止にされています。
        割り込みハンドラの戻り値は重要です。必ず適切な戻り値を返してくだ
        さい。
        
        割り込みハンドラの担当する割り込み要因のデバイス内でさらに細かく
        複数の割り込み要因を持つ場合は、以下のようにコーディングしてくだ
        さい。
        (割り込み要因の成立のタイミングによっては、割り込みハンドラが無駄
        に呼び出される場合がありえます。)
        
          int intrhand(void *common)
           {
        	while( デバイス内の割り込み要因のどれかが成立している ) {
        		割り込み要因に応じた処理;
        	}
        	return 次の割り込みの許可／不許可;
           }
        
        割り込みハンドラが呼ばれた時点で、以下の表の様にレジスタが待避さ
        れています。
        HTYPE_C を指定して、C言語で割り込みハンドラを記述する場合はレジス
        タの待避に関して特に留意しなくても問題ありません。
        HTYPE_ASM を指定した場合は、以下の表で待避レジスタとされていない
        レジスタ ('-'印)を割り込みハンドラで使用する場合は、レジスタの待
        避と復帰を割り込みハンドラ内で行なってください。
        (注意)
         ・割り込みハンドラはスレッド独立部として実行されます。
           したがってシステムのサービスコールの利用には制限があります。
           「マルチスレッドマネージャ管理下でのシステム状態」の節の「スレ
           ッド独立部から発行するサービスコール」を参照してください。
         ・システムのサービスコールは特に明記していない限り C の関数で記述
           されています。
           従って、アセンブラで記述した割り込みハンドラからシステムのサー
           ビスコールをコールするときは、レジスタの待避と復帰を呼出す側が
           行わなければいけません。
        
        +----------+----------+---------+---------+
        |           HTYPE_FULL HTYPE_ASM HTYPE_C  |
        +          +          +         +         +
        |zero       -          -         -        |
        |at         ○         ○        ○       |
        |v0-v1 (2)  ○         ○        ○       |
        |a0-a3 (4)  ○         ○        ○       |
        |t0-t7 (8)  ○         -         ○       |
        |s0-s7 (8)  ○         -         ○       |
        |t8-t9 (2)  ○         -         ○       |
        |k0-k1 (2)  never use  never use never use|
        |gp         ○         -         ○       |
        |sp         ○ (use)   ○ (use)  ○ (use) |
        |fp         ○         -         ○       |
        |ra         ○         ○        ○       |
        |hi, lo (2) ○         ○        ○       |
        |sr         ○         ○        ○       |
        |epc        ○         ○        ○       |
        |           34本       14本      26本     |
        +----------+----------+---------+---------+
        

=========================================================================
RegisterIntrHandler                                                [関数]
=========================================================================
                                                       割込みハンドラ登録
[形式]
        int RegisterIntrHandler( int intrcode, int type, int (*handler)(v
        oid*), void *common );
        
[引数]
        intrcode	割り込み要因を指定します。
        	以下のいずれかの指定ができます。
        	INUM_VBLANK	INUM_GM		INUM_CDROM	INUM_DMA
        	INUM_RTC0	INUM_RTC1	INUM_RTC2	INUM_SIO0
        	INUM_SIO1	INUM_SPU	INUM_PIO       INUM_EVBLANK
        	INUM_DVD	INUM_PCMCIA	INUM_RTC3	INUM_RTC4
        	INUM_RTC5	INUM_SIO2	INUM_HTR0	INUM_HTR1
        	INUM_HTR2	INUM_HTR3	INUM_USB	INUM_EXTR
        	IUNM_DMA_0	IUNM_DMA_1	IUNM_DMA_2	IUNM_DMA_3
        	IUNM_DMA_4	IUNM_DMA_5	IUNM_DMA_6	IUNM_DMA_7
        	IUNM_DMA_8	IUNM_DMA_9	IUNM_DMA_10     IUNM_DMA_11
        	IUNM_DMA_12
        type	割り込みハンドラのレジスタ待避タイプを指定します。
        	アセンブラなら HTYPE_ASM, C言語なら HTYPE_C を指定します。
        handler	割り込みハンドラのエントリポイント
        common	割り込みハンドラと一般ルーチンが共有するメモリへの
		ポインタ。
        	割り込みハンドラは、グローバル変数、スタティック変数に陽に
		アクセスすることはできません。
        	割り込みハンドラが一般ルーチンに何らかの通知をするための
		変数のアドレスは、この common 引数で受け渡します。
        	そのような変数が複数ある場合は、それらを構造体にまとめて
		その構造体のアドレスを common 引数で受け渡します。
        
[返り値]
        KE_OK			正常
        KE_ILLEGAL_INTRCODE	割り込み要因番号が不正
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだしだ
        った
        KE_FOUND_HANDLER	ハンドラは登録済だった
        
[解説]
        外部割り込みハンドラを登録します。
        

=========================================================================
ReleaseIntrHandler                                                 [関数]
=========================================================================
                                                       割込みハンドラ削除
[形式]
        int ReleaseIntrHandler( int intrcode );
        
[引数]
        intrcode	割り込み要因を指定します。
        
[返り値]
        KE_OK				正常
        KE_ILLEGAL_INTRCODE		割り込み要因番号が不正
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだ
				しだった
        KE_NOTFOUND_HANDLER	ハンドラは未登録
        
[解説]
        外部割り込みハンドラを削除します。
        

 9 メモリプール管理関数
========================


=========================================================================
AllocateFpl / pAllocateFpl / ipAllocateFpl                         [関数]
=========================================================================
                                固定長メモリブロック獲得	実装済、未テスト
[形式]
        void * AllocateFpl( int fplid );
        void * pAllocateFpl( int fplid );
        void * ipAllocateFpl( int fplid );
        
[引数]
        fplid	メモリブロックを獲得するを固定長メモリプールIDを指定します。
        
[返り値]
        正(>0)			獲得したメモリブロックのアドレス
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだ
				しだった
        KE_NO_MEMORY		メモリ不足
        KE_UNKNOWN_FPLID	対象固定長メモリプールが存在しない
        KE_RELEASE_WAIT		WAIT状態は強制解除された。
        KE_CAN_NOT_WAIT	ディスパッチ禁止状態で待ち状態に入ろうとした
        KE_WAIT_DELETE	WAIT対象のオブジェクトが削除された。
        
[解説]
        fplid で示した固定長メモリプールからメモリブロックを一つ獲得しま
        す。
        獲得するメモリブロックのサイズは、固定長メモリプール生成時に指定
        されたブロックサイズになります。
        獲得したメモリブロックの内容は不定です。
        
        AllocateFpl サービスコールの場合、指定したメモリプールからメモリ
        ブロックを獲得できなければ、AllocateFpl()を呼び出したスレッドはWA
        IT状態 (メモリ獲得待ち状態)になり、メモリを獲得できるようになるま
        で待ちます。
        
        pAllocateFpl サービスコールは、AllocateFpl サービスコールから WAI
        T状態にはいる機能を取り除いたサービスコールです。
        AllocateFpl と異なりメモリが獲得できない場合エラー(KE_NO_MEMORY)
        で戻ります。
        
[備考]
        AllocateFpl() を割り込み禁止状態で呼ばないでください。
        これは本来エラーになるはずですが、現状は警告をプリントして割り込
        み禁止状態が一旦解除されて他のスレッドに切り替わってしまい、自ス
        レッドがふたたび RUN状態に復帰したときに割り込み禁止状態にもどる
        という動作をします。
        

=========================================================================
AllocateVpl / pAllocateVpl / ipAllocateVpl                         [関数]
=========================================================================
                                可変長メモリブロック獲得 実装済、未テスト
[形式]
        void * AllocateVpl( int vplid, int size );
        void * pAllocateVpl( int vplid, int size );
        void * ipAllocateVpl( int vplid, int size );
        
[引数]
        vplid	メモリブロックを獲得するを可変長メモリプールIDを指定します。
        size	メモリブロックサイズをバイト数で指定します。
        
[返り値]
        正(>0)			獲得したメモリブロックのアドレス
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだ
				しだった
        KE_NO_MEMORY		メモリ不足
        KE_UNKNOWN_VPLID	対象可変長メモリプールが存在しない
        KE_RELEASE_WAIT		WAIT状態は強制解除された。
        KE_CAN_NOT_WAIT	ディスパッチ禁止状態で待ち状態に入ろうとした
        KE_WAIT_DELETE	WAIT対象のオブジェクトが削除された。
        
[解説]
        vplid で示した可変長メモリプールから size バイトのメモリブロック
        を獲得します。
        獲得したメモリブロックの内容は不定です。
        
        AllocateVpl サービスコールの場合、指定したメモリプールからメモリ
        ブロックを獲得できなければ、AllocateVpl()を呼び出したスレッドはWA
        IT状態 (メモリ獲得待ち状態)になり、メモリを獲得できるようになるま
        で待ちます。
        
        pAllocateVpl サービスコールは、AllocateVpl サービスコールから WAI
        T状態にはいる機能を取り除いたサービスコールです。
        AllocateVpl と異なりメモリが獲得できない場合エラー(KE_NO_MEMORY)
        で戻ります。
        
[備考]
        AllocateVpl() を割り込み禁止状態で呼ばないでください。
        これは本来エラーになるはずですが、現状は警告をプリントして割り込
        み禁止状態が一旦解除されて他のスレッドに切り替わってしまい、自ス
        レッドがふたたび RUN状態に復帰したときに割り込み禁止状態にもどる
        という動作をします。
        

=========================================================================
CreateFpl                                                          [関数]
=========================================================================
                                  固定長メモリプール生成 実装済、未テスト
[形式]
        int CreateFpl( struct FplParam *param );
        
[引数]
        param	生成する固定長メモリプールの設定情報をもつ構造体変数へのポ
        インタを指定します。
        	以下のメンバがあります。
        	u_int	attr;
        	u_int	option;
        	int	blockSize;
        	int	numBlocks;
        	各メンバの内容は以下の通りです。
        	attr	固定長メモリプールの属性を指定します。
			以下のどちらかを指定する
        		必要があります。
        		FA_THFIFO 待ちスレッドのキューイングはFIFOで行う
        		FA_THPRI  待ちスレッドのキューイングはスレッドの
				  優先度で行う。
				  また、オプションで、以下の指定を 論理
        			  和で追加できる
        		FA_MEMBTM  メモリプールをメモリボトム
			         （大きいアドレス）に近い方から確保する。
				  未指定の場合はメモリのトップ
				（若いアドレス）に近い方から確保する
        	option	固定長メモリプールに関する付加情報。
			この値は、ReferFplStatus()で参照できます。
        		マルチスレッドマネージャはこの値を関知しません。
        	blockSize  固定長メモリプールから獲得できるメモリブロック
			   のサイズを指定します。
        	numBlocks	固定長メモリプールから獲得できるメモリ
				ブロックの個数を指定します。
        
[返り値]
        正(>0)			固定長メモリプールのID
        KE_NO_MEMORY		メモリ不足
        KE_ILLEGAL_ATTR		attr の指定が不正
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだ
				しだった
        KE_ILLEGAL_MEMSIZE	メモリのサイズ指定が不正
        
[解説]
        固定長のメモリブロックを獲得できるメモリプールを作成します。
        固定長メモリプールは可変長メモリプールと異り一回に獲得できるメモ
        リブロックのサイズが固定長で短い処理時間でメモリを獲得できます。
        

=========================================================================
CreateVpl                                                          [関数]
=========================================================================
                                  可変長メモリプール生成 実装済、未テスト
[形式]
        int CreateVpl( struct VplParam *param );
        
[引数]
        param	生成する可変長メモリプールの設定情報をもつ構造体変数へのポ
        インタを指定
        	します。
        	以下のメンバがあります。
        	u_int	attr;
        	u_int	option;
        	int	size;
        	各メンバの内容は以下の通りです。
        	attr   可変長メモリプールの属性を指定します。
			以下のどちらかを指定する必要があります。
        	      VA_THFIFO    待ちスレッドのキューイングはFIFOで行う
        	      VA_THPRI     待ちスレッドのキューイングはスレッドの
				   優先度で行う。
        	                   また、オプションで、以下の指定を論理和
				   で追加できる
        	      VA_MEMBTM  メモリプールをメモリボトム
				（大きいアドレス）に近い方から確保する。
				未指定の場合はメモリのトップ(若いアドレス）  				    に近い方から確保する。
        	option  可変長メモリプールに関する付加情報。
			この値は、ReferVplStatus()で参照で
        	        きます。
        	        マルチスレッドマネージャはこの値を関知しません。
        	size    可変長メモリプールの全体サイズ（byte数）を指定しま
			す。
        
[返り値]
        正(>0)			可変長メモリプールのID
        KE_NO_MEMORY		メモリ不足
        KE_ILLEGAL_ATTR		attr の指定が不正
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだ
				しだった
        KE_ILLEGAL_MEMSIZE	メモリのサイズ指定が不正
        
[解説]
        可変長のメモリブロックを獲得できるメモリプールを作成します。
        可変長メモリプールからは、メモリプールのサイズを越えない任意のサ
        イズのメモリブロックを獲得できますが、後述の固定長メモリプールに
        比べて処理時間がかかります。
        

=========================================================================
DeleteFpl                                                          [関数]
=========================================================================
                                  固定長メモリプール削除	実装済、未テスト
[形式]
        int DeleteFpl( int fplid );
        
[引数]
        fplid	削除する固定長メモリプールIDを指定します。
        
[返り値]
        KE_OK			正常
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだ
				しだった
        KE_UNKNOWN_FPLID	対象固定長メモリプールが存在しない
        
[解説]
        fplidで示した固定長メモリプールを削除します。
        このメモリプールから確保されたメモリブロックのうち返却されていな
        いものが存在してもエラーにはなりません。
        メモリプール削除後に未返却のメモリブロックを使用した場合のシステ
        ムの動作は保証されません。
        メモリプール削除後に未返却のメモリブロックが使われることが無いよ
        うにアプリケーションプログラムを作成する必要があります。
        メモリ獲得待ちのキューに登録されていたスレッドにはエラーが返され
        ます。
        

=========================================================================
DeleteVpl                                                          [関数]
=========================================================================
                                  可変長メモリプール削除 実装済、未テスト
[形式]
        int DeleteVpl( int vplid );
        
[引数]
        vplid	削除する可変長メモリプールIDを指定します。
        
[返り値]
        KE_OK			正常
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだ
				しだった
        KE_UNKNOWN_VPLID	対象可変長メモリプールが存在しない
        
[解説]
        vplidで示した可変長メモリプールを削除します。
        このメモリプールから確保されたメモリブロックのうち返却されていな
        いものが存在してもエラーにはなりません。
        メモリプール削除後に未返却のメモリブロックを使用した場合のシステ
        ムの動作は保証されません。
        メモリプール削除後に未返却のメモリブロックが使われることが無いよ
        うにアプリケーションプログラムを作成する必要があります。
        メモリ獲得待ちのキューに登録されていたスレッドにはエラー(KE_WAIT_
        DELETE)が返されます。
        

=========================================================================
FreeFpl                                                            [関数]
=========================================================================
                                固定長メモリブロック返却 実装済、未テスト
[形式]
        int FreeFpl( int fplid, void *block );
        
[引数]
        fplid	メモリブロックを返却するを固定長メモリプールIDを指定します。
        block	返却するメモリブロックのアドレスを指定します。
        
[返り値]
        KE_OK		   正常
        KE_ILLEGAL_CONTEXT 例外ハンドラ／割り込みハンドラからの呼びだしだ
        		   った
        KE_ILLEGAL_MEMBLOCK 解放するメモリブロックがメモリプールに属して
        		    いない
        KE_UNKNOWN_FPLID    対象固定長メモリプールが存在しない
        
[解説]
        block で示されるメモリブロックを メモリプール fplid に返却します。
        返却によりメモリプールに空きができた場合、メモリ獲得待ちで WAIT状
        態にあった別のスレッドが、メモリを獲得して WAIT状態が解除されるこ
        とがあります。
        メモリブロックが、指定されたメモリプールから獲得されたものでない
        場合はエラー KE_ILLEGAL_MEMBLOCK になります。
        
[備考]
        現状では、FreeFpl() を割り込み禁止状態で呼んだ場合、WAIT 状態を解
        除されたスレッドが自スレッドよりも優先順位が高いと割り込み禁止状
        態が解除されてそのスレッドに切り替わってしまい、自スレッドがふた
        たび RUN状態に復帰したときに割り込み禁止状態にもどるという動作を
        します。
        この動作はいずれ変更され、割り込み禁止状態が解除されるまでスレッ
        ドの切り替えが遅らされるようになる予定です。
        挙動が変わりますので今は割り込み禁止状態で呼ばないことをおすすめ
        します。
        

=========================================================================
FreeVpl                                                            [関数]
=========================================================================
                                可変長メモリブロック返却	実装済、未テスト
[形式]
        int FreeVpl( int vplid, void *block );
        
[引数]
        vplid	メモリブロックを返却するを可変長メモリプールIDを指定します。
        block	返却するメモリブロックのアドレスを指定します。
        
[返り値]
        KE_OK			正常
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだし				    だった
        KE_ILLEGAL_MEMBLOCK 	解放するメモリブロックがメモリプールに属して
        			いない
        KE_UNKNOWN_VPLID	対象可変長メモリプールが存在しない
        
[解説]
        block で示されるメモリブロックを メモリプール vplid に返却します。
        返却によりメモリプールに空きができた場合、メモリ獲得待ちで WAIT状
        態にあった別のスレッドが、メモリを獲得して WAIT状態が解除されるこ
        とがあります。
        メモリブロックが、指定されたメモリプールから獲得されたものでない
        場合はエラー KE_ILLEGAL_MEMBLOCK になります。
        
[備考]
        現状では、FreeVpl() を割り込み禁止状態で呼んだ場合、WAIT 状態を解
        除されたスレッドが自スレッドよりも優先順位が高いと割り込み禁止状
        態が解除されてそのスレッドに切り替わってしまい、自スレッドがふた
        たび RUN状態に復帰したときに割り込み禁止状態にもどるという動作を
        します。
        この動作はいずれ変更され、割り込み禁止状態が解除されるまでスレッ
        ドの切り替えが遅らされるようになる予定です。
        挙動が変わりますので今は割り込み禁止状態で呼ばないことをおすすめ
        します。
        

=========================================================================
ReferFplStatus / iReferFplStatus                                   [関数]
=========================================================================
                              固定長メモリプール状態参照 実装済、未テスト
[形式]
        int ReferFplStatus( int fplid, struct FplInfo *info );
        int iReferFplStatus( int fplid, struct FplInfo *info );
        
[引数]
        fplid	参照するメモリプールID
        info	メモリプールの状態を受け取る構造体変数へのポインタを
		指定します。
        	以下のメンバがあります。
        	u_int	attr;
        	u_int	option;
        	int	blockSize;
        	int	numBlocks;
        	int	freeBlocks;
        	int	numWaitThreads;
        	各メンバの内容は以下の通りです。
        	attr          CreateFpl()で設定された固定長メモリプール
			      属性
        	option        CreateFpl()で設定された付加情報
        	blockSize     CreateFpl()で設定されたメモリブロックサイズ
			      (byte数)
        	numBlocks     CreateFpl()で設定されたメモリブロック数
        	freeBlocks    メモリプール中の未使用ブロック数
        	numWaitThreads  メモリ獲得待ちをしているスレッド数
        
[返り値]
        KE_OK			正常
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだ
				しだった
        KE_UNKNOWN_FPLID	対象固定長メモリプールが存在しない
        

=========================================================================
ReferVplStatus / iReferVplStatus                                   [関数]
=========================================================================
                              可変長メモリプール状態参照	実装済、未テスト
[形式]
        int ReferVplStatus( int vplid, struct VplInfo *info );
        int iReferVplStatus( int vplid, struct VplInfo *info );
        
[引数]
        vplid	参照するメモリプールID
        info	メモリプールの状態を受け取る構造体変数へのポインタを指定し
		ます。
        	以下のメンバがあります。
        	u_int	attr;
        	u_int	option;
        	int	size;
        	int	freeSize;
        	int	numWaitThreads;
        	各メンバの内容は以下の通りです。
        	attr	CreateVpl()で設定された可変長メモリプール属性
        	option	CreateVpl()で設定された付加情報
        	size  メモリプールから獲得可能な最大可能バイト数
        	      これは、CreateVpl で指定したメモリプールサイズから
		      メモリプールの管理領域の大きさを引いた値になります。
        	freeSize	メモリプール中の未使用メモリバイト数
        	numWaitThreads	メモリ獲得待ちをしているスレッド数
        
[返り値]
        KE_OK			正常
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだ
				しだった
        KE_UNKNOWN_VPLID	対象可変長メモリプールが存在しない
        
[解説]
        可変長メモリプール状態を参照します。
        

 10 時間/ソフトタイマ管理関数
==============================


=========================================================================
alarmhandler                                                       [関数]
=========================================================================
                                           アラームハンドラのプロトタイプ
[形式]
        u_int alarmhandler(void *common);
        
[引数]
        common		SetAlarm()で指定された common が渡されます。
        
[返り値]
        0	このアラームハンドラを削除する。
        1以上	このアラームハンドラを戻り値で示すクロック後、再び呼び出す。
        
[解説]
        アラームハンドラは、その戻り値により再び呼び出しを受けることを指
        定できます。
        アラームハンドラが戻す値が 0 の場合は、そのアラームハンドラは削除
        されます。
        アラームハンドラが戻す値が 1 以上の場合は、ハンドラの今回の呼び出
        し予定時刻に足しこまれて次の呼び出し予定時刻を決定します。
        ただし、100マイクロ秒以下の値の場合には 100マイクロ秒程度に切り上
        げられます。
        
        SetAlarm() の節で説明したようにハンドラの呼び出しは必ずしも正確に
        指定した時刻に行われるわけではなく、遅れる場合がありますが、次の
        ハンドラ呼び出し時刻は実際にハンドラが呼び出された時刻ではなく、
        呼び出し予定時刻を基準に計算されるので、呼び出しの遅れが累積する
        ことはありません。
[備考]
        アラームハンドラは割り込みハンドラの一種です。
        したがってシステムのサービスコールの利用には制限があります。
        iopカーネルライブラリ概要の「マルチスレッドマネージャ管理下でのシ
        ステム状態」を参照してください。
        

=========================================================================
CancelAlarm / iCancelAlarm                                         [関数]
=========================================================================
                                                   アラームハンドラの解除
[形式]
        int CancelAlarm(u_int (*handler)(void*), void *common);
        int iCancelAlarm(u_int (*handler)(void*), void *common);
        
[引数]
        handler	アラームハンドラのエントリポイント
        common	アラームハンドラと一般ルーチンが共有するメモリへのポインタ。
        
[返り値]
        KE_OK			正常
        KE_NOTFOUND_HANDLER	ハンドラは未登録
        
[解説]
        SetAlarm() で設定したアラームハンドラを、時間経過を待たずに解除し
        ます。
        

=========================================================================
DelayThread                                                        [関数]
=========================================================================
                                                             スレッド遅延
[形式]
        int DelayThread(unsigned int usec);
        
[引数]
        usec	停止時間をマイクロ秒単位(表現できるのは 4294.97 秒まで)で
		指定します。
        
[返り値]
        KE_OK			正常
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだ
				しだった
        KE_RELEASE_WAIT		ReleaseWait によって状態が解除された。
        KE_CAN_NOT_WAIT		ディスパッチ禁止状態で待ち状態に入ろうとした
        
[解説]
        自スレッドの実行を一時停止し、時間経過待ち状態に入ります。
        時間経過待ち状態は、WAIT状態の一つですので、ReleaseWaitThread()
        によって時間経過待ち状態を解除することができます。
        停止時間の指定はマイクロ秒単位で指定しますが、100マイクロ秒以下の
        値を指定した場合には 100マイクロ秒程度に切り上げられます。
        複数のスレッドの DelayThread() の終了時刻が近接している(200マイク
        ロ秒以下)場合、遅い方の時刻にまとめて待ち状態から復帰することがあ
        ります。
[備考]
        DelayThread() を割り込み禁止状態で呼ばないでください。
        これは本来エラーになるはずですが、現状は警告をプリントして割り込
        み禁止状態が一旦解除されて他のスレッドに切り替わってしまい、自ス
        レッドがふたたび RUN状態に復帰したときに割り込み禁止状態にもどる
        という動作をします。
        

=========================================================================
GetSystemTime                                                      [関数]
=========================================================================
                                                         システム時刻参照
[形式]
        int GetSystemTime(struct SysClock *clock);
        
[引数]
        clock
        	hi	クロック数の上位 32bitが格納されます
        	low	クロック数の下位 32bitが格納されます
        
[返り値]
        KE_OK	正常
        
[解説]
        システム稼働開始時からの経過時間をクロック数で取得します。
        

=========================================================================
SetAlarm / iSetAlarm                                               [関数]
=========================================================================
                                                   アラームハンドラの設定
[形式]
        int SetAlarm(struct SysClock *clock, u_int (*handler)(void*), voi
        d *common);
        int iSetAlarm(struct SysClock *clock, u_int (*handler)(void*), vo
        id *common);
        
[引数]
        clock
        	hi	ハンドラ起動までの時間の上位 32 bit
        	low	ハンドラ起動までの時間の下位 32 bit
        handler	アラームハンドラのエントリポイント
        common	アラームハンドラと一般ルーチンが共有するメモリへのポインタ。
        
[返り値]
        KE_OK			正常
        KE_NO_MEMORY		メモリ不足
        KE_FOUND_HANDLER	ハンドラは登録済だった
        
[解説]
        指定時間経過後に呼び出されるアラームハンドラを設定します。
        アラームハンドラは、割り込みハンドラに似て引数をひとつ持ち、スレ
        ッド独立部として呼び出されます。
        経過時間の指定はシステムクロック単位で指定しますが、100マイクロ秒
        以下の値を指定した場合には 100マイクロ秒程度に切り上げられます。
        複数のスレッドの DelayThread() の終了時刻やアラームの時間満了が近
        接している (200マイクロ秒以下)場合、遅い方の時刻にまとめて処理さ
        れることがあります。
        アラームハンドラは指定時間経過後に呼び出されたときのハンドラ自身
        の戻り値によって、解除されるか引き続きアラーム動作をするかが決ま
        ります。
        また後述の CancelAlarm()で、指定時間経過を待たずに解除することも
        できます。
        
        マルチスレッドマネージャは、アラームハンドラの同一性を handlerア
        ドレスとその引数( common )のペアで識別しています。
        従って handler アドレスと common がともに等しいアラームハンドラの
        設定は、同一のアラームの２重設定とみなされエラーとなります。
        

=========================================================================
SysClock2USec                                                      [関数]
=========================================================================
                                         システムクロック値を実時間に変換
[形式]
        void SysClock2USec(struct SysClock *clock, int *sec, int *usec);
        
[引数]
        clock
        	hi	変換したいシステムクロック値の上位 32bit
        	low	変換したいシステムクロック値の下位 32bit
        sec	変換した結果の秒の単位を格納する変数へのポインタ
        usec	変換した結果のマイクロ秒の単位を格納する変数へのポインタ
        
[返り値]
        なし
        
[解説]
        システムクロック値をマイクロ秒に変換するユーティリティ関数です。
        

=========================================================================
USec2SysClock                                                      [関数]
=========================================================================
                                     マイクロ秒をシステムクロック値に変換
[形式]
        void USec2SysClock(unsigned int usec, struct SysClock *clock);
        
[引数]
        usec	変換したいマイクロ秒の値を指定します
        clock
        	hi	変換した結果の上位 32bitが格納されます
        	low	変換した結果の下位 32bitが格納されます
        
[返り値]
        なし
        
[解説]
        マイクロ秒をシステムクロック値に変換するユーティリティ関数です。
        
[備考]
        マイクロ秒単位で 32bit無符号整数で表現できるのは 4294.97 秒までで
        す。
        

 11 ハードウェアタイマ管理関数
===============================


=========================================================================
AllocHardTimer                                                     [関数]
=========================================================================
                                                 ハードウェアタイマの取得
[形式]
        int AllocHardTimer(int source, int size, int prescale);
        
[引数]
        source	カウントするソースを TC_SYSCLOCK, TC_PIXEL, TC_HLINE 
		のいずれかで指定します。
        size	タイマのカウンタサイズ（ビット数）を 32 または 16 で指定し
		ます。
        prescale 使用するプリスケールを 1, 8, 16, 256 のいずれかで指定
		します。
        
[返り値]
        正(>0)			タイマのID
        KE_NO_TIMER		ハードウェアタイマは取得できなかった
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだ
				しだった
        
[解説]
        ハードウェアタイマを取得します。
        

=========================================================================
FreeHardTimer                                                      [関数]
=========================================================================
                                                 ハードウェアタイマの返却
[形式]
        int FreeHardTimer(int timid);
        
[引数]
        timid	返却するタイマのID
        
[返り値]
        KE_OK			正常
        KE_ILLEGAL_TIMERID	ハードウェアタイマのIDが不正
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだ
				しだった
        
[解説]
        AllocHardTimer()で取得したハードウェアタイマを返却します。
        

=========================================================================
GetHardTimerIntrCode                                               [関数]
=========================================================================
                                   ハードウェアタイマの割り込み番号の取得
[形式]
        int GetHardTimerIntrCode(int timid);
        
[引数]
        timid	タイマのID
        
[返り値]
        正(>=0)		割り込み番号
        KE_ERROR	なんらかの異常
        
[解説]
        ハードウェアタイマの割り込み番号を取得します。
        
        得られた割り込み番号は、RegisterIntrHandler()の第一引数に使用しま
        す。
        

=========================================================================
GetHoldMode / iGetHoldMode                                         [関数]
=========================================================================
                                         ホールドモードレジスタを読み出し
[形式]
        u_long GetHoldMode(int holdnum);
        u_long iGetHoldMode(int holdnum);
        
[引数]
        holdnum	  ホールドレジスタ番号を 0,1,2,3 のいずれかで指定します。
        
[返り値]
        ホールドモードレジスタの現在値
        
[解説]
        ホールドモードレジスタの値を読みます。
        

=========================================================================
GetHoldReg / iGetHoldReg                                           [関数]
=========================================================================
                                               ホールドレジスタを読み出し
[形式]
        u_long GetHoldReg(int holdnum);
        u_long iGetHoldReg(int holdnum);
        
[引数]
        holdnum   ホールドレジスタ番号を 0,1,2,3 のいずれかで指定します。
        
[返り値]
        ホールドレジスタの現在値
        
[解説]
        ホールドモードレジスタの値を読みます。
        

=========================================================================
GetTimerCompare / iGetTimerCompare                                 [関数]
=========================================================================
                           ハードウェアタイマのコンペアレジスタを読み出し
[形式]
        u_long GetTimerCompare(int timid);
        u_long iGetTimerCompare(int timid);
        
[引数]
        timid	タイマのID
        
[返り値]
        コンペアレジスタの現在値
        
[解説]
        ハードウェアタイマのコンペアレジスタの現在値を読み出します。
        

=========================================================================
GetTimerCounter / iGetTimerCounter                                 [関数]
=========================================================================
                           ハードウェアタイマのカウンタレジスタを読み出し
[形式]
        u_long GetTimerCounter(int timid);
        u_long iGetTimerCounter(int timid);
        
[引数]
        timid	タイマのID
        
[返り値]
        カウンタレジスタの現在値
        
[解説]
        ハードウェアタイマのカウンタレジスタの現在値を読み出します。
        

=========================================================================
GetTimerStatus / iGetTimerStatus                                   [関数]
=========================================================================
                         ハードウェアタイマのステータスレジスタを読み出し
[形式]
        long GetTimerStatus(timid);
        long iGetTimerStatus(timid);
        
[引数]
        timid	タイマのID
        
[返り値]
        ステータスレジスタの現在値
        
[解説]
        ハードウェアタイマのステータスレジスタの現在値を読み出します。
        

=========================================================================
ReferHardTimer                                                     [関数]
=========================================================================
                                     ハードウェアタイマの参照目的での取得
[形式]
        int ReferHardTimer(int source, int size, int mode, int modemask);
        
[引数]
        source	カウントするソースを TC_SYSCLOCK, TC_PIXEL, TC_HLINE
		のいずれかで指定します。
        size	タイマのカウンタサイズ（ビット数）を 32 または 16 で
		指定します。
        mode	タイマに期待する設定モードを指定します。
        modemask タイマに期待する設定モードの着目ビットを指定します。
        
[返り値]
        正(>0)			タイマのID
        KE_NO_TIMER		ハードウェアタイマは取得できなかった
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだ
				しだった
        
[解説]
        参照専用にハードウェアタイマを取得します。
        引数 mode で設定されて稼働中のハードウェアタイマを参照のみの目的
        で取得する場合に使います。
        複数のプログラムから同一のタイマを参照することが可能になります。
        たとえば、以下のように使用します。
        
        xxxx()
        {
        	int timid;
        	timid = ReferHardTimer(TC_HLINE, 16, 期待する mode, 
					期待する mode のマスク);
        	if( timid == KE_NO_TIMER ) {
        	 if( (timid = AllocHardTimer(TC_HLINE, 16, 1)) > KE_OK ) {
        		SetTimerMode( timid , 設定する mode );
        		}
        	}
        	timid > 0 ならば、随時、 GetTimerCounter( timid ) ができる
        }
        

=========================================================================
SetHoldMode / iSetHoldMode                                         [関数]
=========================================================================
                                             ホールドモードレジスタの設定
[形式]
        void SetHoldMode(int holdnum, int mode);
        void iSetHoldMode(int holdnum, int mode);
        
[引数]
        holdnum		ホールドレジスタ番号を 0,1,2,3 のいずれかで指定
			します。
        mode		該当ホールドレジスタのモードを指定します。
        
[返り値]
        なし
        
[解説]
        ホールドモードレジスタの設定を行います。
        

=========================================================================
SetTimerCompare / iSetTimerCompare                                 [関数]
=========================================================================
                               ハードウェアタイマのコンペアレジスタの設定
[形式]
        void SetTimerCompare(int timid, u_long compare);
        void iSetTimerCompare(int timid, u_long compare);
        
[引数]
        timid	タイマのID
        compare	コンペアレジスタに設定する値を指定します
        
[返り値]
        なし
        
[解説]
        ハードウェアタイマのコンペアレジスタの設定をします。
        

=========================================================================
SetTimerCounter / iSetTimerCounter                                 [関数]
=========================================================================
                               ハードウェアタイマのカウンタレジスタの設定
[形式]
        void SetTimerCounter(int timid, u_long count);
        void iSetTimerCounter(int timid, u_long count);
        
[引数]
        timid	タイマのID
        count	カウンタレジスタに設定する値を指定します
        
[返り値]
        なし
        
[解説]
        ハードウェアタイマのカウンタレジスタの設定をします。
        

=========================================================================
SetTimerMode / iSetTimerMode                                       [関数]
=========================================================================
                                 ハードウェアタイマのモードレジスタの設定
[形式]
        void SetTimerMode(int timid, int mode);
        void iSetTimerMode(int timid, int mode);
        
[引数]
        timid	タイマのID
        mode	モードレジスタに設定する値を指定します
        
[返り値]
        なし
        
[解説]
        ハードウェアタイマのモードレジスタを設定します。
        

 12 V-blank 管理関数
=====================


=========================================================================
RegisterVblankHandler                                              [関数]
=========================================================================
                                                      Vblank ハンドラ登録
[形式]
        int RegisterVblankHandler( int edge, int priority, int (*handler)
        (void*), void *common );
        
[引数]
        edge	呼び出しタイミングを指定します。
        	以下のいずれかの指定ができます。
        	VB_START	V-blank 期間の開始時
        	VB_END	V-blank 期間の終了時
        priority 32〜223 で、複数のVblank ハンドラ間の呼び出し優先順位を
        	指定します。
        	小さい数値を持ったハンドラほど先に呼出されます。
        	同一の priority を持った複数のハンドラがあった場合は、先に			登録されたハンドラが先に呼び出されます。
        	優先順位の 0〜31 と 224〜255は予約されています、使用しない
		でください。
        handler	Vblank ハンドラのエントリポイント
        common	Vblank ハンドラと一般ルーチンが共有するメモリへのポインタ。
        
[返り値]
        KE_OK			正常
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだ
				しだった
        KE_FOUND_HANDLER	ハンドラは登録済だった
        KE_NO_MEMORY	登録ハンドラが多すぎる
        
[解説]
        V-blank 期間の開始時と終了時に、呼出される Vblank ハンドラを登録
        します。
        Vblank ハンドラは、割り込みハンドラに似て引数をひとつ持ち、スレッ
        ド独立部として呼び出されます。
        V-blank 期間の開始時と終了時のそれぞれに４つまでハンドラを登録で
        きます。
        
        WaitVblankStart(),WaitVblankEnd(),WaitVblank(),
        WaitNonVblank()のサービスを実現するハンドラも Vblank ハンドラとし
        て登録されており、優先順位は 128 に設定されています。
        
[備考]
        ハードウェアの、V-blank 割り込みが起ると、システムの V-blank 割り
        込みハンドラがこれを受け取ります。
        V-blank 割り込みハンドラは、アプリケーションプログラムが登録した
        複数の Vblank ハンドラを順番に呼び出すことを目的とするハンドラで
        す。
        

=========================================================================
ReleaseVblankHandler                                               [関数]
=========================================================================
                                                      Vblank ハンドラ削除
[形式]
        int ReleaseVblankHandler(int edge, int (*handler)(void*));
        
[引数]
        edge	ハンドラの呼び出しタイミングを指定します。
        	RegisterVblankHandler() での登録時と同じ値を指定します。
        handler	削除したいVblank ハンドラのエントリポイント
        	RegisterVblankHandler() での登録時と同じ値を指定します。
        
[返り値]
        KE_OK			正常
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだしだ
        った
        KE_NOTFOUND_HANDLER	ハンドラは未登録
        
[解説]
        登録したVblank ハンドラを削除します。
        

=========================================================================
vblankhandler                                                      [関数]
=========================================================================
                                            Vblank ハンドラのプロトタイプ
[形式]
        int vblankhandler(void *common);
        
[引数]
        common		RegisterVblankHandler()で指定された common が渡されます。
        
[返り値]
        NEXT_ENABLE	次回の vblank もキャッチする(=1)
        NEXT_DISABLE	本ハンドラを削除する(=0)
        
[解説]
        Vblank ハンドラが戻す値が NEXT_DISABLE の場合は、その Vblank ハン
        ドラは登録を抹消され、次回の Vblank では呼ばれなくなります。
        
[備考]
        Vblank ハンドラは割り込みハンドラの一種です。
        したがってシステムのサービスコールの利用には制限があります。
        iopカーネルライブラリ概要の「マルチスレッドマネージャ管理下でのシ
        ステム状態」を参照してください。
        

=========================================================================
WaitNonVblank                                                      [関数]
=========================================================================
                                          V-blank期間ではなくなるまで待つ
[形式]
        int WaitNonVblank();
        
[引数]
        なし
        
[返り値]
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだし				    だった
        KE_OK			正常
        
[解説]
        V-blank期間ではなくなるまで、発行スレッドはWAIT状態に入ります。
        既にV-blank期間ではない場合は、WAIT状態にならずに戻ります。
        

=========================================================================
WaitVblank                                                         [関数]
=========================================================================
                                                V-blank期間になるまで待つ
[形式]
        int WaitVblank();
        
[引数]
        なし
        
[返り値]
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだ
				しだった
        KE_OK			正常
        
[解説]
        V-blank期間になるまで、発行スレッドはWAIT状態に入ります。
        既にV-blank期間である場合は、WAIT状態にならずに戻ります。
        

=========================================================================
WaitVblankEnd                                                      [関数]
=========================================================================
                                          次の「V-blank期間終了」まで待つ
[形式]
        int WaitVblankEnd();
        
[引数]
        なし
        
[返り値]
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだし				    だった
        KE_OK			正常
        
[解説]
        次の 「V-blank期間終了」まで、発行スレッドはWAIT状態に入ります。
        

=========================================================================
WaitVblankStart                                                    [関数]
=========================================================================
                                          次の「V-blank期間開始」まで待つ
[形式]
        int WaitVblankStart();
        
[引数]
        なし
        
[返り値]
        KE_ILLEGAL_CONTEXT	例外ハンドラ／割り込みハンドラからの呼びだ
				しだった
        KE_OK			正常
        
[解説]
        次の「V-blank期間開始」まで、発行スレッドはWAIT状態に入ります。

 13 キャッシュ操作関数
=======================


=========================================================================
FlushDcache                                                        [関数]
=========================================================================
                                                 データキャッシュのクリア
[形式]
        void FlushDcache();
        
[引数]
        なし
        
[返り値]
        なし
        
[解説]
        CPUのデータキャッシュの内容をクリアします。
        この関数は、DMA などで、プログラムを介在することなくメインメモリ
        が書き換えられたときに、CPU のデータキャッシュとメインメモリの不
        一致を解消するために使用されます。
        使用する必要が生じるのは、主にデバイスドライバでデータ入力をした
        直後ですが、デバイスドライバ内で自動的に行われることが多いので、
        通常のアプリケーションプログラムから呼ぶ必要はあまりないはずです。
        いつ、本関数を呼ぶべきかはデバイスドライバやライブラリのドキュメ
        ントに明記されています。
        

=========================================================================
FlushIcache                                                        [関数]
=========================================================================
                                     インストラクションキャッシュのクリア
[形式]
        void FlushIcache();
        
[引数]
        なし
        
[返り値]
        なし
        
[解説]
        CPUのインストラクションキャッシュの内容をクリアします。
        この関数は、プログラムのロードなどメインメモリ上のプログラムを書
        き換えたときに CPUのインストラクションキャッシュとメインメモリの
        不一致を解消するために用意されていますが、通常、プログラムのロー
        ドのための API の中で自動的に行われますので、通常のアプリケーショ
        ンプログラムから呼ぶ必要はありません。
