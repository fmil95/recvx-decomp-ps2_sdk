[SCEI CONFIDENTIAL DOCUMENT]
"PlayStation 2" Programmer Tool Runtime Library Release 2.0
                  Copyright (C) 2000 by Sony Computer Entertainment Inc.
                                                     All Rights Reserved

USBドライバライブラリ
======================


 1 ライブラリ概要
------------------


  1.1 概要

    USBを扱うソフトウェアは一般に以下のような階層構造を持ちます。
    
        図 1 階層構造

    
    IOP用の常駐ライブラリとして提供されるモジュールusbd.irxは、上記の階層
    のうちHCD, USBD, Hub Driverの3つの機能を持ち、通信先の機器に依存しな
    い処理を受け持ちます（以下の説明では、この3つの機能を総称してUSBDと記
    述しています）。
    マウスやマイクなどのUSB機器を扱いたい場合は、クラス依存の処理を行う
    LDDをユーザ側で作成する必要があります。

  1.2 関連ファイル

    USBドライバに関連するファイルは次のとおりです。USBドライバパッケージ
    を単独でインストールする際には、これらのファイルを開発用コンピュータ
    の/usr/local/sce以下にコピーしてください。
    
    +------------------+----------+
    |カテゴリ           ファイル名|
    +                  +          +
    |ライブラリファイル usbd.ilb  |
    |ヘッダファイル     usb.h     |
    |                   usbd.h    |
    |モジュールファイル usbd.irx  |
    +------------------+----------+
    
    ※iop/install以下のファイルは、/usr/local/sce/iop/gcc/
    mipsel-scei-elfl以下にコピーする必要があります。

  1.3 参考資料

    LDDの作成には、USBの仕様を理解しておくことが必要です。USB仕様一般に関
    しては以下を参照してください。
      http://www.usb.org/developers/docs.html
      

  1.4 サンプルとUSBデバイスの互換性について

    usbd を利用したサンプルには以下のものがあります。
         (1) sce/iop/sample/usb/usbmouse
             sce/ee/sample/usb/usbmouse
             マウスサンプルドライバです。
         (2) sce/iop/sample/usb/usbkeybd
             sce/ee/sample/usb/usbkeybd
             キーボードサンプルドライバです。
    これらのドライバは、USBの標準仕様通りに実装されていますが、一部に正常
    に動作しないUSBデバイスが存在します。これは市販されているUSBデバイス
    の互換性は、第三者機関による審査を受けていないためです。

  1.5 USBバスプロトコルアナライザについて

    市販のUSBバスプロトコルアナライザを使うと、USBバスのプロトコルをトレ
    ース・解析することができます。
    サンプルドライバをそのままご利用して頂く場合、特にアナライザを使用す
    る必要はありませんが、
    新規にドライバを作成（サンプルの改造も含む）したとき、作成したドライ
    バがうまく動かないこともありますので、その際には、プロトコルアナライ
    ザによる解析を行ってください。

 2 LDDの動作原理と作成上の注意点
---------------------------------


   (1) LDD（Logical Device Driver）

      LDDは、デバイスの種別あるいは機種毎に用意されるUSBデバイスドライバ
      です。
      LDDは、以下の３つの外部関数を必ず実装しています。これらの関数は、イ
      ベントが発生したとき、USBDによってコールされます。
         (1) Probe関数（USBバスに新しいデバイスが挿入されたとき、あるいは
             sceUsbdResisterLdd()が呼ばれたときにLDDと関連付けられていな
             いデバイスが存在したときにコールされる）
         (2) Attach関数（Probe関数の戻り値が「このデバイスはこのLDDの担当
             である」だったときコール）
         (3) Detach関数（USBバス上に存在するデバイスが抜かれたときコール）

   (2) LDDの管理

      USBDは、LDD管理構造体（sceUsbdLddOps）を使って、LDDの管理を行います。
        図 2　LDDの管理

      図２は、sceUsbdResisterLdd()を使用して、すでに２つのLDDを登録した状
      態になっています。LDD管理構造体は、LDDと一対一に対応しています。

   (3) USBDとLDDの動作例

      図２の状態で、USBバスにキーボードデバイスが挿入されたときの動作例を
      示します。
      
         (1) 図２の状態で、USBバスにキーボードデバイスが挿入。
         (2) USBDは、そのデバイスにアドレスを与える。
         (3) USBDは、そのデバイスの静的ディスクリプタ（デバイス、コンフィ
             ギュレーション、インターフェース、エンドポイント）を取得する。
             取得された静的ディスクリプタは、「静的ディスクリプタバッファ」
             に保存される。
         (4) 静的ディスクリプタの取得が正常に終了すると、USBDはLDD管理ツリ
             ーを先頭からたどって行く。
         (5) 図2の場合、最初に存在するLDD管理構造体が、USBマウスなので、
             *probeポインタを参照して、USBマウスLDDのprobe関数をコールす
             る。
         (6) USBマウスLDDのprobe関数は、sceUsbdScanStaticDescriptor関数を
             使用して、「静的ディスクリプタバッファ」を参照する。そして、
             これが自分が担当するべきデバイスなのかどうかを判定する。
             このとき、挿入されたデバイスはキーボードなので、probe関数の
             戻り値は「このデバイスはこのLDDの担当ではない」となる。
         (7) 「このデバイスはこのLDDの担当ではない」という戻り値を受け取っ
             たUSBDは、さらにLDD管理ツリーをたどって、次にリンクされてい
             るLDD管理構造体を参照する。
         (8) 次のLDD管理構造体は、USBキーボードLDDの管理構造体である。よっ
             て、USBDは、USBキーボードLDDのprobe関数をコールする。
         (9) USBキーボードLDDのprobe関数は、sceUsbdScanStaticDescriptor()
             を使用して、「静的ディスクリプタバッファ」を参照して、これが
             自分が担当するべきデバイスなのかどうかを判定する。
             このとき、挿入されたデバイスはキーボードなので、probe関数の
             戻り値は「このデバイスはこのLDDの担当である」となる。
         (10) 「このデバイスはこのLDDの担当である」という戻り値を受け取っ
              たUSBDは、LDD管理構造体の*attachポインタを参照して、USBキー
              ボードLDDのattach関数をコールする。
         (11) USBキーボードLDDのattach関数は、このデバイスのためのプライベ
              ートデータを一つ確保する。プライベートデータは、デバイス毎
              に一つ必要（例えば、USBキーボードが３つ存在するとき、プライ
              ベートデータも３つ必要）。確保できれば、
              sceUsbdSetPrivateData()を使用して、このデバイスと関連付ける。
         (12) USBキーボードLDDのattach関数は、
              sceUsbdScanStaticDescriptor()を使用して、「静的ディスクリプ
              タバッファ」を参照して、通信に必要な情報（パケットサイズな
              ど）を収集する。そして、収集した情報をプライベートデータに
              保存する。
         (13) USBキーボードLDDのattach関数は、sceUsbdOpenPipe()あるいは
              sceUsbdOpenPipeAligned()を使用して、通信パイプをオープンす
              る。
         (14) USBキーボードLDDのattach関数は、sceUsbdTransferPipe()を使用
              して必要な通信を行う。
         (15) (1)で挿入されたキーボードが、USBバスから引き抜かれる。
         (16) USBDは、抜かれたデバイスに対応するLDD管理構造体の*detachポイ
              ンタを参照して、そのデバイスを担当していたLDDのdetach関数を
              コールする。
         (17) LDDのdetach関数は、終了処理（プライベートデータの解放）を行
              って戻る。
         (18) USBDは、そのデバイスの通信パイプを閉じる。

   (4) LDD作成上の注意点

      LDDのUSBイベント関数（probe,attach,detach）及びコールバック関数（転
      送終了時に呼ばれる）は、図3のような仕組みで呼ばれます。
        図 3　USBDがLDDの関数を呼ぶ仕組み

      
      図３の「割込み処理用スレッド」と「転送終了後コールバック処理用スレ
      ッド」は、それぞれ一つだけ生成されます（バス上のデバイス数に関係無
      く）。
      そのため、USBイベント関数あるいはコールバック関数で以下のような待ち
      処理等を行うと問題が生じます。
      
         (1) DelayThread() 等による時間遅延
         (2) 他のスレッドからのセマフォ、イベントフラグ、メッセージを待つ
         (3) 特定の変数が変更されるのを while(var == 0) ; のように待つ (こ
             の処理は USBD に限らず問題があります)
         (4) その他、待ち処理ではないが上記 (1),(2),(3) に処理時間のオーダ
             が一致するような重い処理。
      
    上記のような待ち処理を行うと、その待ち状態が解除されるまではUSBD 内の
    スレッドに戻らず、USBD のUSBイベント及びコールバック呼び出しが全て止
    まります。
    
    解除されれば再開はされますが、時間制限のあるデバイスの場合はデータの
    取りこぼし等が発生します。また、時間制限がなくとも例えばマウスポイン
    タが一瞬動かなくなるなどの問題が生じます。
    
    USBD を使う際には USBイベント関数およびコールバック関数内では処理はご
    く短時間に終えて下さい。待ち処理は許されません。
    待ち処理が必要な場合には以下のような方法を取って下さい。
    
         (1) 待ち処理と次の転送要求を発行するためのスレッドを生成する。
         (2) コールバック関数はイベントフラグのセットなどの処理のみにし、
             すぐに呼び出し元へ戻る。
         (3) (1) のスレッドは (2) を待ち、必要な待ち処理を行った後に、次の
             転送要求を USBD に対して伝える。
    
    ※(1)のスレッドの優先度は、USBDのスレッドの優先度よりも低くしてくださ
    い。
    

 3 制限事項および注意事項
--------------------------


   (1) 割り込み

      USBDの各エントリ関数は、割り込みコンテキストからは呼び出せません。

   (2) パケットサイズが63,64バイトの際の注意事項

      Interrupt / Control / Bulk転送の際には最大で4KBまでのデータ転送要求
      を指定できますが、実際の転送はパケットサイズに分割されて行われます。
      ハードウェアの不具合によってパケットサイズが63,64バイトのときに起こ
      る問題を回避するため、USBDは以下の条件をすべて満たすときには最大パ
      ケットサイズを62バイトに設定しています。
      
            ・Interrupt(OUT) / Control(IN/OUT) / Bulk(OUT)転送時
            ・パケットサイズが63または64バイト（MaxPacketSizeが64）
            ・ControlパイプまたはsceUsbdOpenPipe()によるパイプでの転送時
      
      大量のデータを上記の条件で転送する場合には、若干パフォーマンスが低
      下します。転送速度の向上、または64バイトごとの転送を必要とする場合
      はsceUsbdOpenPipeAligned()を使用してください。

   (3) Isochronous転送時の注意事項

      Isochronous転送時に、IOP側でおよそ300サイクル以上の期間、メモリバス
      のバス権がブロックされてしまうと転送に失敗する場合があります。
      このデータ転送失敗時に返されるエラーは、データIN転送（host←dev）の
      場合はBufferOverrun、データOUT転送（host→dev）の場合は
      BufferUnderrunとなります。
      Isochronous転送時には、IOPでは以下のような処理を行わないようにして
      ください。
      
            ・300サイクル以上にわたるDMA禁止
            ・キャッシュフラッシュ処理
            ・DMAC割り込みルーチン内での300サイクル以上の処理
      
    

 4 USBDの起動オプション
------------------------

    以下にusbd.irxの起動オプションを示します。XXXおよびYYYはすべて10進数
    です。なお、起動オプションに不正な値を指定した場合の動作は保証しませ
    ん。
    
    +-------------+----------------------------------------+------------+
    |オプション    機能                                     デフォルト値|
    +             +                                        +            +
    |dev=XXX       デバイス数の上限                         32          |
    |ed=XXX        エンドポイント数の上限                   64          |
    |gtd=XXX       General Transfer Descriptor数の上限      128         |
    |itd=XXX       Isochrnous Transfer Descriptor数の上限   128         |
    |ioreq=XXX     I/O転送要求数の上限                      256         |
    |conf=XXX      デバイスごとの静的ディスクリプタバイト数 512         |
    |hub=XXX       Root hub以外のHUBデバイス数              8           |
    |port=XXX      HUBごとの最大ポート数                    8           |
    |thpri=XXX,YYY USBDが生成する２つのスレッドの優先度     30,36       |
    +-------------+----------------------------------------+------------+
    

    dev=XXX

      USBDが同時に扱うデバイス数の上限値を指定します。このデバイス数には
      root hubデバイスも含みます。またデバイスが接続されていなくてもポー
      トが存在するだけで1つのデバイス領域を消費します。たとえばHubを一切
      使用しない場合に必要なデバイス数は、root hubと2ポートで3となります。
      128を越える値を指定してはいけません。

    ed=XXX

      USBDが同時に扱うエンドポイント数の上限値を指定します。エンドポイン
      ト数にはコントロール・エンドポイントも含まれます。

    gtd=XXX

      Isochronous転送以外に使用されるTransfer Descriptor数の上限値を指定
      します。
      データ転送がないControl転送では、1つの転送に2つのgtdを消費します。
      データ転送を含むControl転送では3つのgtdを消費します。Interrupt転送
      およびBulk転送では、1つの転送に常に1つのgtdを消費します。

    itd=XXX

      Isochornous転送時に使用されるTransfer Descriptor数の上限値を指定し
      ます。
      Isochornous転送では1つの転送に常に1つのitdを消費します。

    ioreq=XXX

      sceUsbdTransferPipe()で同時に要求できる転送の最大数を指定します。こ
      こで指定した数までは、前に要求した転送の終了を待たずに重ねて要求す
      ることができます。

    conf=XXX

      デバイスごとの静的ディスクリプタの総バイト数を指定します。

    hub=XXX

      root hubを除くHUBデバイスの最大数を指定します。

    port=XXX

      各HUBの持つポート数の最大値を指定します。

    thpri=XXX,YYY

      USBＤ生成するスレッドの優先度を指定します。
       XXXは、割込み処理用スレッドの優先度。
       YYYは、コールバック処理用スレッドの優先度。
      ※ XXXの優先度は、YYYよりも高く（数値的に小さく）して下さい。
