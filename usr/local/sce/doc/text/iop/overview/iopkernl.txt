[SCEI CONFIDENTIAL DOCUMENT]
"PlayStation 2" Programmer Tool Runtime Library Release 2.0
                  Copyright (C) 2000 by Sony Computer Entertainment Inc.
                                                     All Rights Reserved

IOP Kernel API
===============


 1 ライブラリ概要
------------------


  1.1 概要

    IOP Kernelは、IOP上で動作するオペレーティングシステムです。優先度ベー
    スのシンプルでリアルタイム処理に適したマルチスレッドスケジューリング
    機能を持ち、セマフォ / イベントフラグ / メッセージボックスによるスレ
    ッド間同期・通信、割り込みハンドラの管理、メモリプールの管理、タイマ
    管理、V-blank同期などの機能をシステムコールとして提供します。
    また、IOPプログラムはメモリ上でモジュールとして管理されますが、その管
    理とともに、モジュールの一部を他のモジュールにサブルーチンとして提供
    する「常駐ライブラリ」の機能をサポートします。

  1.2 ソフトウェア階層

    IOPのメモリ上に存在するソフトウェアは、以下の階層構造を持ちます。
    
    

   (1) IOPサービスプログラム群

    IOPサービスプログラムは、下層に位置するさまざまなマネージャ、ドライバ、
    カーネルを呼び出して、IOPが果たすべきI/O processerとしての仕事を実現
    するプログラムです。
    IOPサービスプログラムは、EEとの通信をハンドリングするデバイスドライバ
    からEEのリクエストを受け取り、そのリクエストに基づいたI/O動作を適切な
    I/Oデバイスドライバを呼び出して実行し、その結果をEEに返します。

   (2) システムメモリマネージャ

    システムメモリマネージャは、メモリ領域全体の管理を行い、上層のソフト
    ウェアに対して次の機能を提供します。
          (a) 全メモリサイズの取得
          (b) メモリエリアの割り当て（メモリの先頭から割り付け）
          (c) メモリエリアの割り当て（メモリの末尾から割り付け）
          (d) メモリエリアの解放
    メモリの割り当ては256byte単位で行います。メモリの使用イメージは次のよ
    うになります。
    
    
    標準では、システムメモリマネージャを直接呼び出してメモリを確保するの
    はマルチスレッドマネージャとプログラムローダだけで、デバイスドライバ
    以上の層のプログラムは、マルチスレッドマネージャの提供するメモリ割り
    当てサービスを利用します。

   (3) プログラムローダ

    プログラムローダは、CD-ROM / DVD-ROM / ROM等からプログラムモジュール
    をメモリにロードし、メモリ上のモジュールを管理します。下層にあたるモ
    ジュールマネージャと上層にあたるファイルローダで構成されています。
    モジュールマネージャは次の機能を持ちます。
         ・メモリ上のプログラムモジュールの管理
         ・常駐ライブラリの管理（ロード時のリンク処理を含む）
         ・リロケータブルモジュールのメモリ上への配置
    ファイルローダは、モジュールマネージャとファイルシステムマネージャを
    呼び出して以下の機能を実現します。
         ・プログラムモジュールファイルのロード
         ・プログラムモジュールファイルとメモリ上モジュールのバージョン比
           較、置き換え

   (4) 例外ハンドラマネージャ

    例外ハンドラマネージャは、CPUの各例外（INT,IBE,DBE,Sys,Bp...）ハンド
    ラへのジャンプテーブルの管理ルーチンと、例外を判定して各ハンドラに制
    御を渡す統合例外ハンドラで構成されます。通常のアプリケーションから呼
    び出されることはなく、主にデバッグシステムとマルチスレッドマネージャ
    から利用されます。

   (5) 割り込みハンドラマネージャ

    割り込みハンドラマネージャは、割り込みハンドラの登録・管理ルーチンと、
    割り込み要因を判定して各ハンドラに制御を渡す統合割り込みハンドラで構
    成されます。IOPには20数本の割り込み要因があり、要因別のマスクレジスタ
    とマスターマスクレジスタによって割り込み禁止 / 許可を設定することがで
    き、これらのマスクを操作する関数が用意されています。割り込みが発生す
    ると、割り込みハンドラマネージャは割り込みステータスレジスタとマスク
    レジスタを参照して割り込み要因を判定し、登録されている適切な割り込み
    ハンドラを呼び出します.

   (6) マルチスレッドマネージャ

    CPU資源の管理とメモリ資源の管理、割り込み資源の管理を行い、上層のソフ
    トウェアに対して次の機能を提供します。
          (a) スレッドの管理機能
          (b) スレッドのスケジューリング機能
          (c) スレッド間の同期機能
          (d) メモリ管理機能
          (e) 割り込み管理機能

   (7) デバイスドライバ群

    デバイスドライバは、マルチスレッドマネージャの機能を使用し、各I/Oデバ
    イスをハンドリングするモジュールで、次の３つの部分で構成されます。
         ・割り込み処理ルーチン（必要があれば）
         ・デバイスコントロールスレッド（0個以上）
         ・エントリ関数群
    エントリ関数群は、上層のプログラムから呼び出されて、I/Oリクエストをデ
    バイスコントロールスレッドに渡すかまたは直接デバイスをコントロールす
    る処理を行います。エントリ関数群自体は、呼び出し側スレッドのコンテキ
    ストで実行されます。

   (8) ファイルシステムマネージャ

    ファイルシステムマネージャは、open(), close(), read(), write()などデ
    バイスに依存しないファイルアクセスAPIを提供し、デバイスドライバが持つ
    これらのエントリ群の登録管理を行います。

  1.3 関連ファイル

    IOP Kernel APIを利用するのに必要なファイルは次のとおりです。
    
    +--------------+----------+
    |カテゴリ       ファイル名|
    +              +          +
    |ヘッダファイル kernel.h  |
    +--------------+----------+
    

 2 マルチスレッド管理
----------------------


  2.1 スレッドの概要

    スレッドとは、並行処理の観点から見た、プログラムの論理的な単位です。
    アプリケーションプログラムの処理内容を複数のスレッドに分け、それらを
    同時並行的に動作させることができます。同時並行といってもCPUはひとつし
    かありませんから、ある短い時間内で見ると、実行されているスレッドはひ
    とつだけです。どのスレッドが実行されるかは、各スレッドの状態と優先度
    によって決められます。優先度の高いスレッドが実行中であればそのスレッ
    ドが待ち状態に入るか割り込みハンドラ中で状態が変更されない限り、それ
    より優先度の低いスレッドが実行されることはありません。複数のタスク（
    またはプロセス）を切り替えながらまんべんなく実行しようとするTSS（Time
     Sharing System）とはこの点で大きく異なっています。
    入出力装置やメモリ上の特定のワークエリアなどの資源は、スレッド間で排
    他的に使用するように調整しなければなりません。IOP Kernelはスレッド間
    の同期・通信機能として、セマフォ／イベントフラグ／メッセージボックス
    を提供しています。
    なお、スレッドと割り込みハンドラは明確に区別されます。スレッドはあく
    までユーザプログラムの一部として、割り込みハンドラはカーネルの一部と
    して、それぞれ異なるシステム状態のもとで実行されます。これに関連して、
    プログラムを記述するうえでいくつか注意すべき点があります。

  2.2 スレッドの状態と動作

    IOP Kernelの管理するスレッドは、以下の7つ（大きく見ると５つ）の状態を
    もちます。
    
    +------------+------------------------------------------------------+
    |状態         説明                                                  |
    +            +                                                      +
    |RUN          実行状態。CPUがそのスレッドを実行中の状態             |
    |READY        実行可能な状態。CPUが他のスレッドを実行中であるため   |
    |             待機している状態                                      |
    |WAIT         待ち状態。ある条件が成立するまで、自ら待ちに入った状態|
    |SUSPEND      強制待ち状態。他のスレッドが発行したシステムコールに  |
    |             よって強制的に待ちに入れられた状態                    |
    |WAIT-SUSPEND 2重待ち状態。WAIT状態であったときに他のスレッドから   |
    |             強制的に待ちに入れられた状態                          |
    |DORMANT      休止状態。スレッドが生成されてまだ起動されていない状態|
    |             、または終了してから削除されるまでの状態              |
    |NON-EXSITENT 未登録状態。スレッドが生成されていない、または削除され|
    |             た後の仮想的な状態                                    |
    +------------+------------------------------------------------------+
    
         ・RUN：実行状態
           CPUがそのスレッドを実行中であるという状態です。ある瞬間につい
           て見れば、この状態のスレッドはひとつしかありません。
         ・READY：実行可能状態
           そのスレッドは実行できる条件が整っているが、より優先度の高い（
           あるいは同じ）スレッドが実行中であるために待機している状態です。
           READY状態のスレッドが複数個ある場合、それらのスレッドはCPUが空
           くのを待って待ち行列を作ります。これをレディキューと呼びます。
         ・WAIT：待ち状態／SUSPEND：強制待ち状態／WAIT-SUSPEND：2重待ち状
           態
           そのスレッドが実行できる条件が整わないため実行を止められている、
           実行保留状態です。WAITは自スレッドの発行したシステムコールによ
           って実行が止まっている状態、SUSPENDは他のスレッドから強制的に
           止められている状態、WAIT-SUSPENDはWAIT中にさらに他スレッドによ
           って止められた状態です。
           待ち状態からの実行再開は、実行を中断した場所から行われ、プログ
           ラムカウンタやレジスタなどプログラムの実行状態を表現する情報（
           コンテキスト）はそのまま復元されます。
         ・DORMANT：休止状態
           スレッドがまだ起動されていない状態、または終了した状態。スレッ
           ドを生成するとまずこの状態になります。
         ・NON-EXISTENT：未登録状態
           スレッドが作成される前、または削除されたあとの、仮想的な状態で
           す。
    
    生成されたスレッドはまずDORMANT状態になり、起動されることによって
    READY状態となってレディキュー（詳細後述）に入り、レディキューの先頭に
    あるスレッドが実行されてRUN状態となります。RUN状態のスレッドは、スリ
    ープするかまたはセマフォなどの条件を待つことによってWAIT状態に移り、
    待ち条件が成立するとREADY状態に戻ります。

  2.3 スレッドのスケジューリング

    READY状態にある複数のスレッドをどのような順序で実行する（RUN状態に移
    す）か、その調整・制御をスケジューリングと呼びます。IOP Kernelでのス
    ケジューリングについて以下説明します。

   (1) 優先度

    スレッドはそれぞれ優先度を持ち、READY状態のスレッドはそれぞれの持つ優
    先度にしたがってスケジューリングされ実行されます。実行されているスレ
    ッドが同一優先度以下のスレッドにCPUを奪われる（RUN状態からはずされる）
    ことは、基本的にはありません。優先度の範囲は1〜126で、数値の小さいほ
    うが高い優先度を表します。一部の優先度はシステムで予約されていて、ユ
    ーザプログラムで使用できる優先度の範囲はUSER_HIGHEST_PRIORITY（=9） 
    〜 USER_LOWEST_PRIORITY（=123）に限られています。

   (2) レディキュー

    RUN状態およびREADY状態のスレッドを、実行される優先順位にしたがって並
    べたものがレディキューです。レディキューの並び順は各スレッドが持つ優
    先度の高い順で、同一優先度のスレッドどうしは早くREADY状態になった順に
    並びます。
    たとえば次のように、優先度11のスレッドA、優先度12のスレッドB、C、D、
    優先度13のスレッドE、Fがレディキューに存在するとします。
    
    
    レディキューにあるもっとも優先度の高いスレッドはスレッドAなので、スレ
    ッドAが実行されます。スレッドAの実行中、暗黙のうちに他のスレッドに実
    行が移ることはありません。スレッドAがWAIT状態になると、レディキューは
    下図のようになり、スレッドBが実行されます。
    
    
    実際のプログラミングにおいては、各スレッドは処理が一段落したり外部の
    処理を待たねばならなくなったところでWAIT状態に移るようにしておきます。

   (3) 割り込みとスケジューリング

    割り込みが発生すると（割り込み禁止状態でなければ）割り込みハンドラに
    制御が移り、割り込みハンドラからリターンする時点で、各スレッドの状態
    と優先度にしたがって再度スケジューリングが行われます。
    割り込みハンドラ内でスレッドAをREADY状態に移したりスレッドBの優先度を
    下げたりする処理が行われない限り、割り込みハンドラから戻ったあともや
    はりスレッドBが実行されます。割り込みハンドラ内でスレッドAがREADY状態
    に移されると、リターン時の再スケジューリングでスレッドAがRUN状態にな
    り、スレッドBはRUN状態からREADY状態に移ります（スレッドBがプリエンプ
    トされた、といいます）。この場合でもレディキュー内のスレッドBの位置は
    変わらないので、スレッドAがレディキューから外れれば再びスレッドBが実
    行されます。
    
    
    実際のプログラミングにおいては、割り込み発生時に行うべき処理をWAIT状
    態のスレッドとして待機させておき、割り込みハンドラ内でそのスレッドを
    READY状態に移してリターンする、といった処理が一般的です。

   (4) 優先度の変更

    スレッドの優先度は、ChangeThreadPriority()を用いて変更することができ
    ます。自分自身の優先度を変更することもできますし、他のスレッドの優先
    度を変更することもできます。また、レディキューを回転させる
    RotateThreadReadyQueue()を用いて、優先度の同じスレッドどうしの実行順
    序を変更することができます。たとえば優先度12をRotateReadyQueue()によ
    って回転すると、先頭のスレッドが最後尾に移ってC,D,Bの順となります。
    またスレッド独立部（割り込みハンドラ内）では、iChangeThreadPriority()
    を用いてスレッドの優先度を変更したり、iRotateThreadReadyQueue()を用い
    てレディキューを回転させることができます。
    なお、待ち状態のスレッドがREADY状態に移った場合は、そのスレッドは該当
    優先度のレディキューの最後尾につきます。

  2.4 スレッド間の同期

    スレッドどうしの間で、入出力デバイスへのアクセス競合などを避けたり、
    同期して処理を行うために、IOP Kernelはいくつかの同期機能を提供してい
    ます。

   (1) スレッドのスリープ・起床

      各スレッドは、処理が一段落したり外部デバイスの処理を待たねばならな
      くなるなど、CPUを当面必要としなくなった時点でSleepThread()を呼び出
      し、WAIT状態に移ることができます。これを「スリープする」といいます。
      スリープしているスレッドは、他のスレッドまたはスレッド独立部から
      WakeupThread() / iWakeupThread()を用いてREADY状態に戻すことができま
      す。これを、「スレッドを起床する」といいます。

   (2) イベントフラグ

      イベントフラグはより柔軟な同期処理を行うことができます。一時に多数
      のスレッドを起床するプログラムなどで有用です。
      まず、フラグの初期値を設定してイベントフラグを作成しておきます。条
      件の成立を待つスレッドはWaitEventFlag()を呼び出して、解除条件を指定
      してWAIT状態に移ります。他のスレッドまたは割り込みハンドラが
      SetEventFlag() / iSetEventFlag()によってフラグ値を変更すると、イベ
      ントフラグを待っているスレッドのうち、新しいフラグ値が解除条件に合
      致するものがREADY状態に戻ります。

   (3) セマフォ

      複数のスレッドが同じデバイスやバッファ領域などを使用する場合に、使
      用状況を他のスレッドに知らせて同期を取るために用意されているのがセ
      マフォ（信号機）機能です。
      デバイス等を使用したいスレッドはWaitSema()を実行してセマフォ資源を
      取得し、つまり使用中フラグを立てることで使用権を取得してから使用し
      ます。使い終われば、SignalSema()を実行してセマフォ資源をシステムに
      返却します。
      
      WaitSema()を実行したときにもし他のスレッドがデバイス等を使用中であ
      れば、セマフォ資源は取得できず、そのスレッドはWAIT状態になってセマ
      フォ待ち行列に入ります。デバイス等を使い終わったスレッドが
      SignalSema()を実行してセマフォ資源をシステムに返却すると、返却され
      たセマフォ資源がセマフォ待ち行列の先頭のスレッドに与えられ、そのス
      レッドはREADY状態に戻り、優先度によるスケジューリングにしたがって実
      行され、デバイス等を使用できるようになります。
      
      セマフォ資源の個数はセマフォ作成時に指定することができるため、上記
      のような排他制御のほかに、複数のスレッドがデータを供給する共有バッ
      ファの有効データ数を表すような使いかたも可能です。データ供給側のス
      レッドは、共有バッファにデータを格納したときにSignalSema()を実行し
      て有効データが増えたことを示します。それに対してデータ消費側のスレ
      ッドは、共有バッファからデータを取り出そうとするときにWaitSema()を
      実行して、セマフォ資源が取得できれば共有バッファ中のデータを処理し、
      取得できなければWAIT状態になってデータが供給されるのを待つことにな
      ります。

   (4) メッセージボックス

      メッセージボックスはスレッド間でのデータ交換をサポートするサービス
      で、セマフォとリングバッファの組み合わされたものと考えることもでき
      ます。
      まずCreateMbx()を用いてメッセージボックスを作成しておきます（複数可）
      。メッセージを待つスレッドはメッセージボックスの番号を指定して
      ReceiveMbx()を発行してWAIT状態に入ります。他のスレッドまたはスレッ
      ド独立部からSendMbx() / iSendMbx()でメッセージボックスの番号を指定
      してメッセージを送信すると、そのメッセージボックスで待っているスレ
      ッドがREADY状態に移されます。
      

 3 その他のサービス
--------------------


  3.1 メモリ割り当てサービスの概要

    マルチスレッドマネージャは、メモリ領域をヒープとして管理し、アプリケ
    ーションプログラムからの要求に応じてメモリブロックを割り当てるサービ
    スを提供しています。
    ヒープの形式として、メモリブロックのサイズが固定されているヒープと、
    割り当てのたびにブロックサイズを指定できるヒープの2形式があります。ま
    た、空き領域がなく割り当てができないときには空き領域ができるまで待つ
    （WAIT状態になる）ものと、エラーとしてリターンするものと、2種類のAPI
    が用意されています。

  3.2 モジュール管理の概要

    IOPのメモリ上にロードされた個々のプログラムをモジュールと呼びます。モ
    ジュールはROMあるいはCD/DVD-ROMに格納されたリロケータブルオブジェクト
    ファイル（IRXファイル）と１対１に対応します。

   (1) モジュールの構造

    モジュールは次の3つのセグメントで構成されます。
         (1) TEXT segment：プログラムコード、エントリテーブル構造体（後述）
             、呼び出しテーブル構造体（後述）
         (2) DATA segment：初期値付きデータ
         (3) BSS segment：初期値なしデータエリア
    DATA segmentとBSS segmentは無い場合もあります。各セグメントのサイズは
    16byteの整数倍で、上記の順序でメモリアドレスの小さいほうから連続して
    配置されます。
    モジュールにはそれぞれモジュール名とバージョンを持たせることができま
    す。バージョンはメジャーバージョンとマイナーバージョンと、それぞれ1〜
    255の範囲で付けることができます。
    モジュールは以下の形式の起動エントリを持たねばなりません。起動エント
    リはモジュールがロードされたときに呼び出され、その返り値に応じて常駐
    処理が行われます。
        int startentry( int argc, char *argv[] );
    起動エントリは起動エントリ専用のスレッドで実行されます。優先度は8で、
    スタックは2KBが用意されています。起動エントリに渡されるパラメータは、
    LoadStartModule()で指定されたargsおよびargpを、一般的なC言語のmain関
    数の引数と同じポインタ配列形式にスタック上で並べ替えたものとなります。

   (2) 常駐ライブラリ

    モジュールのプログラムコードの一部を、他のモジュールからサブルーチン
    として呼び出せるライブラリとしてシステムに登録することができます。こ
    のように、他のモジュールに対してサブルーチンを提供するモジュールを特
    に常駐ライブラリと呼びます。
    常駐ライブラリは、他モジュールに提供するサブルーチンのエントリアドレ
    スをまとめたエントリテーブル構造体を持ち、起動時に
    RegisterLibraryEntries()を用いてシステムに登録します。一方、常駐ライ
    ブラリのサブルーチンを利用したいモジュールは、利用したいサブルーチン
    のインデックスをまとめた呼び出しテーブル構造体を持ちます。そのモジュ
    ールがロードされるときに、呼び出しテーブルが登録済みのライブラリと照
    合され、該当するサブルーチンのエントリアドレスに書き換えられます。
    
    

  3.3 割り込み管理の概要

    割り込みコントローラやDMA割り込み等の割り込み要因解析は、割り込みハン
    ドラマネージャが行います。要因ごとに複数の割り込みハンドラを登録する
    機能があり、割り込みハンドラ内から、スレッドの起床やイベントフラグの
    設定などを行ってスレッドをコントロールすることができます。

  3.4 タイマ管理の概要

    IOPの持つハードウェアタイマの制御機能に加えて、指定した時間だけ自スレ
    ッドを停止する機能、指定した時間が経過した時点で特定の関数（アラーム
    ハンドラ）を呼び出すアラーム機能が用意されています。時間はマイクロ秒
    またはシステムクロック単位で指定しますが、実装上、100〜200マイクロ秒
    程度切り上げて（遅らされて）実行される場合があります。

  3.5 Vblank管理の概要

    V-blankと同期する処理をサポートするために、V-blank期間の開始 / 終了ま
    で自スレッドを停止するAPIが用意されています。また、V-blank期間の開始
    または終了時に特定の関数（Vblankハンドラ）を呼び出す機能が用意されて
    います。

 4 注意事項
------------


  4.1 スレッド部とスレッド独立部

    マルチスレッドマネージャの環境下では、スレッド部を実行中のシステム状
    態とそれ以外の部分を実行中のシステム状態は異なっています。スレッド以
    外の部分、つまり割り込みハンドラを作成する際には、システム状態の違い
    を意識してプログラミングする必要があります。
    割り込みハンドラやタイマハンドラなどのスレッド独立部では、スレッド独
    立部に入る直前に実行中だったスレッドを特定することが無意味で「自スレ
    ッド」の概念が存在しません。また、実行中のスレッドを特定できないので
    スレッドのディスパッチングは起きません。ディスパッチングが必要になっ
    ても、それはスレッド独立部を抜けるまで遅らされます（これを遅延ディス
    パッチ状態と呼びます）。
    スレッド独立部からは、待ち状態にはいるサービスコールや暗黙で自スレッ
    ドを指定するサービスコールを発行することは原理的に不可能です。また、
    マルチスレッドマネージャの実装上の都合で、同じ機能であってもスレッド
    部から発行するサービスコールとは内部処理が異なる場合があります。そこ
    で、スレッド独立部から発行できるサービスコールは、スレッド部から発行
    するサービスコールとは異なるエントリ名で用意されています。すなわち、
    名前の先頭に'i'（英小文字）の付くサービスコールだけがスレッド独立部か
    ら発行することができます。たとえば、スレッドを起床するサービスコール
    WakeupThread()は、スレッド独立部から発行する場合は、iWakeupThread()と
    して発行します。不適切なシステム状態のもとで発行されたサービスコール
    はエラーを返します。
