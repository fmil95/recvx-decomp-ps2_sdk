[SCEI CONFIDENTIAL DOCUMENT]
"PlayStation 2" Programmer Tool Runtime Library Release 2.0
                  Copyright (C) 2000 by Sony Computer Entertainment Inc.
                                                     All Rights Reserved

IOP module loader specification
================================


 1 概要
--------

    このドキュメントでは、IOPプログラムローダの動作と扱うデータの構造につ
    いて説明します。
    IOPのメモリ上には複数のプログラムをロードすることが可能です。
    
    メモリ上にロードされた一つのプログラムをプログラムモジュール、あるい
    は単にモジュールと呼びます。
    プログラムモジュールは、ROM、CD-ROM/DVD-ROM上にリロケータブルなオブジ
    ェクトファイルとして格納され、メモリへのロード時にリロケーションされ
    ます。
    IOPオブジェクトファイルは通常 '.irx'の拡張子をもち、IRXファイルと呼ば
    れることもあります。
    
    モジュールは起動エントリをひとつ持ちます。モジュールのロード直後に起
    動エントリが呼び出され、その戻り値によってモジュールがメモリに常駐す
    るか否かが決定されます。
    またロードされたモジュールは、他のモジュールからサブルーチンとして呼
    び出される複数のエントリを持つことが可能です。このように他のモジュー
    ルから呼び出されるサブルーチンエントリを持つモジュールを特に常駐ライ
    ブラリと呼ぶことがあります。
    
    IOPプログラムローダは、CD-ROM/DVD-ROM, ROM等のファイルからプログラム
    モジュールのロード/リロケートとメモリ上でのモジュールの管理を行います。
    

 2 モジュールの構造
--------------------


  2.1 セグメントの配置

    IOPのメモリ上では一つのモジュールは以下の３つのセグメントからなり、各
    セグメントは下図の順で連続して配置され、それぞれのサイズは16byteの倍
    数でなければなりません。
    
      TEXT segment	--  プログラムコード（必須）
      インストラクションコードと後述のエントリテーブル構造体と呼び出しテ
      ーブル構造体が含まれます。
      それ以外のデータは入るべきではありません。
      DATA segment	--  初期値つきデータ（無い場合もある）
      BSS segment	--  初期値無しデータエリア（無い場合もある）
    
    

  2.2 モジュールID

    メモリ上にロードされたモジュールには識別用のID番号が割り当てられます。
    このID番号をモジュールIDと呼びます。
    

  2.3 モジュール名とモジュールバージョン

    モジュールには、モジュール名とモジュールバージョンをつけることができ
    ます。
    モジュールのソースプログラム中で、以下のように宣言します。
    
      ModuleInfo Module = {"Module_name", バージョン番号 };
    
    グローバル変数名Moduleはモジュール名とモジュールバージョンを指定する
    用途の為に予約されています。
    ModuleInfo構造体は、このようになっています。
    
      typedef struct _moduleinfo {
      char		*name;
      unsigned short	version;
      } ModuleInfo;
    
    nameフィールドは、モジュールの名称を指定します。
    名称に使用する文字は、英数字、'_'、'/' だけを使用することを推奨します。
    
    versionフィールドの上位8bitは、モジュールのメジャーバージョンを設定し、
    下位8bitは、マイナーバージョンを設定します。
    メジャーバージョン、マイナーバージョンとも、1以上の値を用います。
    0は使用しないでください。
    
    モジュール名とモジュールバージョンは、主に以下の用途で使用されます。
    
         ・システムブート時にブートローダがリプレースモジュールを検知する
           ため
         ・プログラマがデバッグ中のモジュールのロードアドレスを把握するた
           め
         ・デバッガがブート済のモジュールとディスク上のオブジェクトファイ
           ルの同一性を確認するため
    
    ただし、IOPプログラムローダはモジュール名とモジュールバージョンがつい
    ていないプログラムでも問題なくロードし実行することができます。
    
    注意： プログラムローダがモジュール名とモジュールバージョンを利用して
    同一モジュールの複数回ロードを禁止するような処理はしていません。
    この動作は今後も変更する予定はありません。

 3 モジュール間のリンクの仕組み
--------------------------------

    IOPプログラムローダはモジュールのロード時に該当モジュールが他のロード
    済モジュール（常駐ライブラリ）を呼び出しているかどうかを検査し、必要
    な場合他のモジュールとのリンクを行います。
    このリンク機能は以下に述べる二つの構造体を操作することで行われます。

  3.1 エントリテーブル構造体

    常駐ライブラリモジュールは、他のモジュールに提供するひとまとまりの関
    数群をライブラリとしてシステムに登録することができます。
    ひとまとまりの関数群は以下のエントリテーブル構造体で記述され、モジュ
    ールの起動時にモジュール自身によってプログラムローダのAPI 
    RegisterLibraryEntries()を使用してシステムに登録します。
    ひとつのモジュールが登録できるエントリテーブル構造体の数に制限はあり
    ません。つまり、ひとつのモジュールが複数のライブラリを登録することが
    できます。
    
      	.text
      	.set noreorder
      	.globl  mylib_entry
    mylib_entry:
      	.word  0x41c00000	/* magic number of entry table */
      	.word  0			/* reserved */
      	.short  0x0101		/* version */
      	.short  0x0000		/* flags */
      	.ascii  "mylib\0\0\0"	/* library name (max 8 characters) */
      	.align  2
      
      	.word		MylibEntry1	/* address of function 1 */
      	.word		MylibEntry2	/* address of function 2 */
      	.word		MylibEntry3	/* address of function 3 */
      	.word		MylibEntry4	/* address of function 4 */
      	:
      	:
      	.word  0		/* table end mark */
    
    後述の予約エントリの規定により、エントリ関数は４つ以上登録されていな
    ければなりません。
    
    エントリテーブル構造体は、通常loplibgenユーティリティなどで生成します。
    「sce/doc/iop/tool/compile.htm」を参照してください。
    (上記中 'flags' のフィールドは、現在は、IOPシステムがエントリテーブル
    の管理の為に使用するフィールドです。かならず0を入れてください。)

  3.2 予約エントリ

    エントリテーブル構造体に登録されている関数は実行時にはテーブル内の順
    番（インデックス）によって識別されます。
    原則としては、関数名とテーブル内のインデックスの対応はプログラミング
    時にプログラマが自由に決めて構いません。
    しかし、システムサービスの管理上の都合で最初の４つのエントリは関数名
    に関わらず、以下のように役割が固定されています。
    
    +------------+--------------------------------------------+
    |インデックス 関数の機能                                  |
    +            +                                            +
    |0            ライブラリの初期処理用に予約（詳細未定）    |
    |1            ライブラリの再初期化処理用に予約（詳細未定）|
    |2            ライブラリの終了処理                        |
    |3            予約（詳細未定）                            |
    +------------+--------------------------------------------+
    
    この４つのエントリは、該当する関数がある場合にはその関数を登録し、無
    い場合には、何もせずに単にリターンする関数を登録しなければなりません。
    
    ライブラリの終了処理関数は、以下のprototypeを持ちます。
    
    	void  lib_terminate(int mode);
    
    引数modeにより、終了処理関数を呼ぶ原因が指定されます。
    
    +----+----------------------------------+
    |mode 原因                              |
    +    +                                  +
    |0    システム終了（reboot準備）        |
    |1    モジュール削除（現在未実装、予約）|
    +----+----------------------------------+

  3.3 呼び出しテーブル構造体

    常駐ライブラリモジュールが提供する関数群を使用するモジュールは以下の
    形式の呼び出しテーブル構造体をリンクします。
    エントリテーブル構造体と異なり、自モジュールが必要とする関数だけをテ
    ーブルに含みます。
    IOPプログラムローダは、モジュールのロード直後に呼び出しテーブル構造体
    中のjump命令を書き換えてモジュール間のリンクを行います。
    
      	.text
      	.set noreorder
      	.globl  mylib_stub
    mylib_stub:
      	.word  0x41e00000	/* magic number of call table */
      	.word  0			/* reserved */
      	.short  0x0101		/* version */
      	.short  0x0000		/* flags */
      	.ascii  "mylib\0\0\0"	/* library name (max 8 characters) */
      	.align  2
      
      	.globl          MylibEntry1
    MylibEntry1:
      	j      $31
      	.half   0		/* entry table index */
      	.half   0x2400	/* index magic : 0x2400XXXX == addiu $0,$0,XXXX */
      
      	.globl		MylibEntry2
    MylibEntry2:
      	j      $31
      	.half   2		/* entry table index */
      	.half   0x2400	/* index magic */
      	:
      	:
      	:
      	.word   0, 0	/* table end mark */
    
    呼び出し関数エントリを一つも含まない呼び出しテーブル構造体は許されま
    せん。
    
    呼び出しテーブル構造体は、通常loplibldユーティリティなどで自動生成し
    ます。
    「sce/doc/iop/tool/compile.htm」を参照してください。
    (上記中 'flags' のフィールドは、現在は、IOPシステムが呼び出しテーブル
    の管理の為に使用するフィールドです。かならず0を入れてください。)

  3.4 ilbファイルフォーマット

    常駐ライブラリを作成した場合、ライブラリ名とライブラリバージョン、お
    よびライブラリ中の各関数の名前とテーブルインデックスの対応を記述した
    データファイル（ilbファイル）を作成する必要があります。
    このファイルはライブラリを利用する側のモジュールのリンク時に、呼び出
    しテーブル構造体を作成するための情報として利用されます。
    
    このデータファイルの形式は、以下の様に桁固定形式のテキストファイルと
    し、データファイルの拡張子は '.ilb' とすることにします。
    
      #IOP-ILB# 任意の文字列
      L ライブラリ名
      V 0xHHHH
      F 0xHHHH
      E ddd entryname
      E ddd entryname
      E ddd entryname
    
    最初の '#IOP-ILB#'で始まる行は続くテキスト行がilb-data形式であること
    を宣言します。
    'L' で始まる行は必ず2行目に位置し,3桁目から行末まで8文字以内のライブ
    ラリ名
    'V' で始まる行は必ず3行目に位置し,5桁目から4桁の16進数
    'F' で始まる行は必ず4行目に位置し,5桁目から4桁の16進数で0を指定します。
    5行目以降は'E'で始まり3桁目から3桁の10進数と、7桁目から行末までのエン
    トリ名
    
    複数のilb-data形式を結合して一つのファイルに格納して良いものとします。
    その場合は '#IOP-ILB#'を区切り記号とみなします。

  3.5 リンク時の互換性チェック

    前述のようにエントリテーブル構造体と呼び出しテーブル構造体にはlibrary
     nameフィールドとversionフィールドがあります。
    library nameフィールドは8byteのサイズを持ち、8byteに満たない名前の場
    合はnull文字でパディングしてください。
    versionフィールドの上位8bitは、ライブラリのメジャーバージョンを設定し、
    下位8bitは、マイナーバージョンを設定します。
    versionフィールドの設定は、基本的にはプログラマに任されていますが、次
    の規定があります。
    メジャーバージョンは、関数テーブルの並び順、及び関数の仕様に互換性の
    ある場合、同じ値を取るように設定しなければいけません。
    マイナーバージョンは、バグフィックスや後方互換を保った機能追加が行わ
    れたときに更新します。
    メジャーバージョン、マイナーバージョンとも、1以上の値を用います。
    0は使用しないでください。
    
    モジュールがIOPメモリ上にロードされて、そこに含まれる呼び出しテーブル
    構造体がリンクされるときには、library nameフィールドと、メジャーバー
    ジョンが一致する登録済のエントリテーブル構造体が検索され、見つかると
    リンクされます。
    (注意：2000年4月現在、プログラムローダは上記のように動作しますが、呼
    び出しテーブル構造体の指定するマイナーバージョンよりも小さいマイナー
    バージョンのエントリテーブル構造体とはリンクが出来ない方が望ましいの
    で、いずれそのように変更する予定です。)
    
    エントリテーブル構造体のシステムへの登録時は、既に登録されているライ
    ブラリにlibrary nameとメジャーバージョンが一致して、マイナーバージョ
    ンが大きいものが存在した場合は、登録に失敗します。

 4 モジュールのロードと起動の手順
----------------------------------

    プログラムローダはIOPのシステムのブート時およびLoadStartModule()など
    のAPIにより指示があったときに、IOPオブジェクトファイルをロードしモジ
    ュールの起動エントリを呼び出します。

  4.1 モジュールのロード

    モジュールのロードは以下の手順で行われます。
         (1) IOPオブジェクトファイル形式のオブジェクトデータを調べ、必要な
             メモリ領域を確保し、オブジェクトの再配置を行います。
         (2) モジュールのBSS segmentをゼロクリアします。
         (3) モジュールのTEXT segmentを調査し、呼び出しテーブル構造体を発
             見したならばリンクします。
         (4) モジュールIDの割り当てを行います。

  4.2 モジュールの起動

    モジュールの起動エントリは次のようなプロトタイプを持たなければなりま
    せん。
    
    	int startentry(int argc, char *argv[]);
    
    プログラムローダは、起動エントリを以下のように呼び出します。
         (1) モジュールのGP(global pointer) valueをGP register($28)にセッ
             トする。
         (2)  起動エントリをサブルーチンコールする。
    
    起動エントリが呼び出されたときの引数、スタック等は、システムのブート
    時と平常時とでは異なり、以下のようになります。
    

    システムのブート時

      スタックは、ブート時にシステムが使用しているおよそ3KBのスタックを使
      用する。
      argc = 0
      argv = NULL
      

    平常時

      起動エントリ実行用に確保されているスレッドの権限で実行される。
      スレッドのスタックサイズは2KB
      スレッドの優先順位はMODULE_INIT_PRIORITY(=8)
      argc = 一般的なC言語のmain関数の引数と同じ。(1以上)
      argv = 一般的なC言語のmain関数の引数と同じ。
      文字列ポインタ配列および文字列の実体はスタック上に積まれている。
    
    起動エントリ実行用に確保されているスレッドは一つしかないので、原則と
    して起動エントリの実行は複数が並行に行われることはありません。
    プログラマは通常のモジュールの起動エントリのプログラミングでは他のモ
    ジュールの起動エントリ処理との競合を気にする必要はありません。
    例外として、起動エントリのなかで、LoadStartModule()などのAPIによりさ
    らに他のモジュールを起動する場合は、起動エントリの実行がネストします。
    
    起動エントリの戻り値の下位2bitは以下の意味を持ちます。
    
    +----------------+--------------------------------+
    |戻り値の下位2bit 処理                            |
    +                +                                +
    |0                モジュールはメモリに常駐する    |
    |1                モジュールはメモリから削除される|
    |2                予約値（使用不可）              |
    |3                予約値（使用不可）              |
    +----------------+--------------------------------+
    

 5 IOPオブジェクトフォーマット
-------------------------------

    IOPオブジェクトフォーマットは、MIPS R3000のELF形式リロケータブルファ
    イルフォーマットに若干の追加・変更・制限を加えたものです。

  5.1 IOPモジュール情報セクション

    IOPオブジェクトフォーマットには、IOPモジュール情報セクションが新規に
    追加されました。
    IOPモジュール情報セクションは以下の構造の可変長のデータを持ち、IOPプ
    ログラムローダがモジュールをロードした後に実行に必要な情報を設定しま
    す。
    
        /* A section of type SHT_SCE_IOPMOD contains the following 
        structure.  */
        typedef struct _Elf32_IopMod {
        	Elf32_Word	moduleinfo;
        	Elf32_Word	entry;
        	Elf32_Word	gp_value;
        	Elf32_Word	text_size;
        	Elf32_Word	data_size;
        	Elf32_Word	bss_size;
        	Elf32_Half	moduleversion;
        	char		modulename[1];	/* null terminate */
        } Elf32_IopMod;
    
    entryは、プログラムの起動エントリアドレスのTEXT segment先頭からのオフ
    セットが入ります。
    gp_valueは、プログラムのGP registerの値のTEXT segment先頭からのオフセ
    ットが入ります。
    text_size, data_size, bss_sizeはそれぞれTEXT, DATA, BSS segmentのサイ
    ズを示します。
    プログラムのDATA segment中にModuleInfo構造体のModule変数が存在すると
    きは、moduleinfoにModule変数のTEXT segment先頭からのオフセットが入り、
    さらに、moduleversionにModule.versionのコピーが、modulename[]には、
    Module.nameのコピーが格納されます。
    Module変数が存在しないときは、moduleinfoには0xffffffff、moduleversion
    とmodulename[0]には、0が入ります。
    
    IOPモジュール情報セクションのセクション名は ".iopmod"となり、セクショ
    ンヘッダの各フィールドには以下の値が格納されます。
    
    sh_type	=  SHT_SCE_IOPMOD(=0x70000080)
    sh_offset	=  セクションデータのファイル先頭からのオフセット
    sh_size	=  sizeof(Elf32_IopMod)+strlen(Elf32_IopMod.modulename)
    sh_addralign	=  4
    その他	=  0
    
    なお、IOPオブジェクトファイルには .reginfoセクションは不要です。
    .reginfoセクションは入れないでください。

  5.2 ファイル中のデータレイアウト

    標準のELF形式リロケータブルファイルではファイル中のデータの配置はとく
    に規定されていませんが、IOPオブジェクトフォーマットでは以下の順にデー
    タが並んでいなければいけません。
    
         (1) ELFヘッダ
         (2) プログラムヘッダテーブル
         (3) IOPモジュール情報セクションデータ
         (4) TEXT, DATA segmentデータ
         (5) その他のセクションデータ
         (6) セクションヘッダテーブル
         (7) TEXT, DATA segmentのリロケーションテーブルデータ
         (8) その他のセクションデータ

  5.3 メモリ中のデータレイアウト

    IOPモジュールは「2. モジュールの構造」で述べたようにレイアウトされて
    いる必要があります。
    すなわち、TEXT, DATA, BSS各セグメントはこの順で連続して配置されalign
    は0x10、つまり16byte境界でなければなりません。
    
    UNIXなどでは、.rodataセクションのような書き換え不可のデータをTEXT 
    segmentに含ませることがありますが、IOPのオブジェクトファイルではこれ
    は許されません。

  5.4 ELFヘッダの詳細

    ELFヘッダの内容は、以下のように設定されなければなりません。
    
      e_ident	== 'ELF', ELFCLASS32, ELFDATA2LSB,  EV_CURRENT
      e_type	== ET_SCE_IOPRELEXEC (==0xFF80)
      e_machine  == EM_MIPS
      e_version  == EV_CURRENT
      e_flags	== 任意（無視される）
      e_entry	== プログラムの起動エントリアドレスのTEXT segment先頭からの
      オフセット
      	(Elf32_IopMod.entryと同じ値)
      e_ehsize	== sizeof(Elf32_Ehdr)
      e_phoff	== プログラムヘッダテーブルのファイル内の位置
      	( sizeof(Elf32_Ehdr)と同じになる)
      e_phentsize  == sizeof(Elf32_Phdr)
      e_phnum  == 2
      e_shoff	== セクションヘッダテーブルのファイル内の位置
      e_shentsize  == sizeof(Elf32_Shdr)
      e_shnum  == ファイル中のセクションの数
      e_shstrndx  == .shstrtabセクションのセクションインデックス

  5.5 プログラムヘッダテーブルの詳細

    プログラムヘッダテーブルは必ず２つの要素を持ち、以下の順になっていま
    す。
    
    IOP Module Header
      p_type	== PT_SCE_IOPMOD( == 0x70000080)
      p_flags	== PF_R
      p_offset	== IOPモジュール情報セクションのデータのファイル内の位置
      p_filesz	== IOPモジュール情報セクションのデータのサイズ
      	sizeof(Elf32_IopMod)+strlen(Elf32_IopMod.modulename)
      p_vaddr,p_memsz  == 0
      p_align	== 4
    Segment Header
      p_type	== PT_LOAD
      p_flags	== PF_R+PF_W+PF_X
      p_offset	== TEXT segment データのファイル内の位置
      p_vaddr	== 0
      p_filesz	== ファイル中のロードデータのサイズ
      	(TEXT segment size + DATA segment size)
      p_memsz  == メモリにロード後のデータサイズ
      (TEXT segment size + DATA segment size + BSS segment size)
      p_align	== 0x10

  5.6 予約シンボル

    SCE製のIOPオブジェクトファイルジェネレータiopfixupでは、以下の予約シ
    ンボルを自動生成します。
    
      _ftext		TEXTセグメントの先頭アドレス
      _etext, etext	TEXTセグメントの最後のbyteの次のアドレス
      _fdata		DATAセグメントの先頭アドレス
      _edata, edata	DATAセグメントの最後のbyteの次のアドレス
      _fbss		BSSセグメントの先頭アドレス
      _end, end	BSSセグメントの最後のbyteの次のアドレス
      _gp		gpレジスタの初期値
    
    上記のシンボル間では以下の関係が成り立ちます。
      0 <= ( _fdata - _etext ) < 0x10
      0 <= ( _fbss - _edata ) < 0x10
    
    プログラムのソース互換性を確保するために、リンカまたはIOPオブジェクト
    ファイルジェネレータは、上記のシンボルを生成することを推奨します。

  5.7 シンボルテーブルエントリ

    シンボルテーブルのテーブルエントリのst_valueフィールドの保持する値が
    アドレスである場合、それはセクションオフセットではなく、プログラムオ
    フセット（TEXT segmentの先頭からのオフセット）となります。
    
    また、上記の予約シンボルのうち、etext, _etext, edata, _edata, _fbss,
    end, _end, _gpのエントリは、st_shndxフィールドにSHN_RADDR(==0xff1f)が
    入ります。
    
    それ以外は、標準のR3000用ELFリロケータブルファイルと同じです。

  5.8 リロケーションテーブルエントリ

    リロケーションテーブルのテーブルエントリのr_offsetフィールドはプログ
    ラムオフセット（TEXT segmentの先頭からのオフセット）が格納され、r_sym
    フィールド(==ELF_32_R_SYM(r_info))は常にSTN_UNDEFが格納されます。
    
    ELFリロケータブルファイルから IOP オブジェクトファイルに変換する際に、
     r_sym フィールドが示しているシンボルの値をプログラムオフセットに変換
    したのち、該当セクションデータのリロケーションフィールドに適切に足し
    込まれなければなりません。
    
    許されるリロケーションタイプは以下の6タイプのみです。
      R_MIPS_NONE
      R_MIPS_16
      R_MIPS_32
      R_MIPS_26
      R_MIPS_HI16
      R_MIPS_LO16
    また、対応するR_MIPS_HI16とR_MIPS_LO16は、オリジナルのMIPSのR3000での
    定義のとおり、必ずペアでテーブル上に連続して格納されなければいけませ
    ん。
    ( gccの拡張では、一つのR_MIPS_HI16に複数のR_MIPS_LO16が存在する場合が
    ありますが、これは許されません。)
    
    それ以外は、標準のR3000用ELFリロケータブルファイルと同じです。

  5.9 デバッグ情報

    IOPオブジェクトフォーマットでは、デバッグ情報に関しての規定は行いませ
    ん。
    また、IOPプログラムローダは、本文書で規定した以外のセクションを無視し
    ます。
    従って、コンパイラベンダは独自のデバッグ情報を含むセクションをIOPオブ
    ジェクトファイルに含めてかまいません。
    ただし、SCE製のユーティリティは、SCE供給のiop-gcc(標準のR3000用gccと
    ほぼ同じ)の生成するデバッグ情報がセクション名 ".mdebug"セクションタイ
    プSHT_MIPS_DEBUGであることを前提にしているので、MIPS用gccと非互換のデ
    バッグ情報を生成する場合は、これらのセクション名またはセクションタイ
    プを使用してはいけません。
