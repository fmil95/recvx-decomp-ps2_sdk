<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"><HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">
<META NAME="GENERATOR" CONTENT="Adobe FrameMaker 5.5/HTML Export Filter">
<LINK REL="STYLESHEET" HREF="ee.css" CHARSET="ISO-8859-1" TYPE="text/css">
<TITLE> DVP Assembler</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffff">
<DIV>
<TABLE CLASS="ECOS" WIDTH="98%" BORDER="0" ALIGN="LEFT" CELLPADDING="1">
<TR>
<TH COLSPAN="3" ALIGN="center">
<P CLASS="Gotos">
DVP Assembler</P>
</TH></TR>
<TR><TD  ALIGN="center">
<P CLASS="Gotos">
<A HREF="ee-15.html">
To&nbsp;main&nbsp;page</A>
</P></TD>
<TD  ALIGN="center">
<P CLASS="Gotos">
<A HREF="ee-18.html">
To&nbsp;previous&nbsp;page</A></P></TD>
<TD ALIGN="center">
<P CLASS="Gotos">
<A HREF="ee-20.html">
To&nbsp;next&nbsp;page</A></P>
</TD>
</TR></TABLE>
<P ALIGN="LEFT">&nbsp;</P>
<BR>
<BR>
<HR ALIGN="center">
</DIV>
<H2 CLASS="Heading1">
<A NAME="pgfId-469532"></A><A NAME="32461"></A>DVP Assembler</H2>
<P CLASS="Body">
<A NAME="pgfId-542042"></A>The <A NAME="marker-802958"></A>DVP Assembler allows a combination of DMA tags, GIF tags, VIF instructions, and VU instructions to be assembled from a single input stream to produce an <A NAME="marker-802960"></A>ELF object file.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId-460669"></A><A NAME="15783"></A>Emotion Engine-specific command-line options</H3>
<P CLASS="Body">
<A NAME="pgfId-495299"></A>For a list of available generic assembler options, refer to &quot;Command-Line Options&quot; in <EM CLASS="Emphasis">
Using AS</EM>
 in <STRONG CLASS="BoldEmphasis">
GNUPro Utilities</STRONG>
. </P>
<P CLASS="BodyHang1">
<A NAME="pgfId-802966"></A><TT CLASS="Code">
-no-dma</TT>
<A NAME="marker-802965"></A></P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-802967"></A>Do not include DMA instructions in the output.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId-802969"></A><TT CLASS="Code">
-no-dma-vif</TT>
<A NAME="marker-802968"></A></P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-802970"></A>Do not include DMA or VIF instructions in the output.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId-461429"></A>Syntax</H3>
<P CLASS="Body">
<A NAME="pgfId-492016"></A>For a list of available generic description of assembler syntax, refer to &quot;Syntax&quot; in <EM CLASS="Emphasis">
Using AS</EM>
 in <STRONG CLASS="BoldEmphasis">
GNUPro Utilities</STRONG>
.</P>
<P CLASS="Body">
<A NAME="pgfId-492017"></A>There are two types of <A NAME="marker-524424"></A>comments: inline comments and line comments. In both cases, the comment is equivalent to one space. Anything from <TT CLASS="Code">
'/*'</TT>
 to <TT CLASS="Code">
'*/'</TT>
 is an inline comment. Inline comments can span multiple lines but cannot be nested. A line comment is everything from <TT CLASS="Code">
`;'</TT>
 to the next newline.</P>
<P CLASS="Body">
<A NAME="pgfId-492020"></A>A <A NAME="marker-524425"></A>statement ends at a <A NAME="marker-515569"></A>newline character (<TT CLASS="Code">
&#92;n</TT>
). There is no line separator character; there can be no more than one statement on a line.</P>
<P CLASS="Body">
<A NAME="pgfId-529059"></A>A statement begins with an optional label, optionally followed by a key symbol and appropriate operands. A <A NAME="marker-529060"></A>label is a symbol that is immediately followed by a colon (:). The <A NAME="marker-529061"></A>key symbol <A NAME="marker-529062"></A>(opcode) determines the syntax of the rest of the statement. The <A NAME="marker-529063"></A>mode of the assembler determines which set of opcodes is acceptable.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId-492224"></A><A NAME="marker-535724"></A>Literals</H3>
<P CLASS="Body">
<A NAME="pgfId-504857"></A>For a generic description of numeric and character constants (literals), refer to &quot;Syntax&quot; in <EM CLASS="Emphasis">
Using AS</EM>
 in <STRONG CLASS="BoldEmphasis">
GNUPro Utilities</STRONG>
.</P>
<P CLASS="Body">
<A NAME="pgfId-534643"></A>The DVP and MIPS assemblers support a new format for quadword literals. The format of this literal is <TT CLASS="Code">
'0x'</TT>
 followed by four 1-word hexadecimal values separated by the underscore (<TT CLASS="Code">
'_'</TT>
) character.</P>
<P CLASS="Body">
<A NAME="pgfId-534647"></A>For example, the literal:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-534649"></A>	0x333_0_12345678_1</P>
<P CLASS="Body">
<A NAME="pgfId-534651"></A>can be used, and is equivalent to:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-534641"></A>	0x0000033300000000123456780000001</P>
<H3 CLASS="Heading2">
<A NAME="pgfId-496366"></A><A NAME="marker-496365"></A><A NAME="27097"></A>Directives</H3>
<P CLASS="Body">
<A NAME="pgfId-488410"></A>The DVP assembler accepts a subset of the directives described in <EM CLASS="Emphasis">
Using AS</EM>
 in <STRONG CLASS="BoldEmphasis">
GNUPro Utilities</STRONG>
. In addition, the DVP assembler also accepts a number of new directives.</P>
<P CLASS="Body">
<A NAME="pgfId-803088"></A>This is a complete list of DVP assembler directives: </P>
<TABLE BORDER="1">
<CAPTION>
<P CLASS="TableTitle">
<A NAME="pgfId-802977"></A>DVP Assembler directives</P>
</CAPTION>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-802985"></A><TT CLASS="Code">
.ascii</TT>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-802987"></A><TT CLASS="Code">
.EndGif</TT>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-802989"></A><TT CLASS="Code">
.if</TT>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-802991"></A><TT CLASS="Code">
.quad</TT>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-802993"></A><TT CLASS="Code">
.asciz</TT>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-802995"></A><TT CLASS="Code">
.endm</TT>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-802997"></A><TT CLASS="Code">
.ifdef</TT>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-802999"></A><TT CLASS="Code">
.rept</TT>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-803001"></A><TT CLASS="Code">
.balign</TT>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-803003"></A><TT CLASS="Code">
.EndMpg</TT>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-803005"></A><TT CLASS="Code">
.ifndef</TT>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-803007"></A><TT CLASS="Code">
.sbttl </TT>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-803009"></A><TT CLASS="Code">
.byte</TT>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-803011"></A><TT CLASS="Code">
.EndUnpack</TT>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-803013"></A><TT CLASS="Code">
.include</TT>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-803015"></A><TT CLASS="Code">
.section</TT>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-803017"></A><TT CLASS="Code">
.data</TT>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-803019"></A><TT CLASS="Code">
.equ</TT>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-803021"></A><TT CLASS="Code">
.int</TT>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-803023"></A><TT CLASS="Code">
.set</TT>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-803025"></A><TT CLASS="Code">
.DmaData</TT>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-803027"></A><TT CLASS="Code">
.equiv</TT>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-803029"></A><TT CLASS="Code">
.irp</TT>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-803031"></A><TT CLASS="Code">
.short</TT>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-803033"></A><TT CLASS="Code">
.DmaPackVif</TT>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-803035"></A><TT CLASS="Code">
.err</TT>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-803037"></A><TT CLASS="Code">
.irpc</TT>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-803039"></A><TT CLASS="Code">
.skip</TT>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-803041"></A><TT CLASS="Code">
.eject</TT>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-803043"></A><TT CLASS="Code">
.exitm</TT>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-803045"></A><TT CLASS="Code">
.list</TT>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-803047"></A><TT CLASS="Code">
.space</TT>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-803049"></A><TT CLASS="Code">
.else</TT>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-803051"></A><TT CLASS="Code">
.extern</TT>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-803053"></A><TT CLASS="Code">
.macro</TT>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-803055"></A><TT CLASS="Code">
.string</TT>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-803057"></A><TT CLASS="Code">
.EndDirect</TT>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-803059"></A><TT CLASS="Code">
.fill</TT>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-803061"></A><TT CLASS="Code">
.nolist</TT>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-803063"></A><TT CLASS="Code">
.text</TT>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-803065"></A><TT CLASS="Code">
.EndDmaData</TT>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-803067"></A><TT CLASS="Code">
.float</TT>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-803069"></A><TT CLASS="Code">
.org</TT>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-803071"></A><TT CLASS="Code">
.title</TT>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-803073"></A><TT CLASS="Code">
.endfunc</TT>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-803075"></A><TT CLASS="Code">
.func</TT>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-803077"></A><TT CLASS="Code">
.p2align</TT>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-803079"></A><TT CLASS="Code">
.vu</TT>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-803081"></A><TT CLASS="Code">
.endif</TT>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-803083"></A><TT CLASS="Code">
.global</TT>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-803085"></A><TT CLASS="Code">
.psize</TT>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-803087"></A><TT CLASS="Code">
.word</TT>
</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-462943"></A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId-462946"></A>For information on most supported directives, refer to <EM CLASS="Emphasis">
Using AS</EM>
 in <STRONG CLASS="BoldEmphasis">
GNUPro Utilities.</STRONG>
 Some existing assembler directives have been modified for the DVP Assembler. In addition, the DVP Assembler also supports several new directives.</P>
<P CLASS="Body">
<A NAME="pgfId-505770"></A>The following list describes the new and modified directives that the DVP assembler supports:</P>
<P CLASS="BodyHang1">
<A NAME="pgfId-803094"></A><TT CLASS="Code">
.DmaData</TT>
<A NAME="marker-803093"></A></P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-803095"></A>Builds a labeled block of DMA data for use with <TT CLASS="Code">
DMAref</TT>
. </P>
<P CLASS="BodyHang1">
<A NAME="pgfId-803097"></A><TT CLASS="Code">
.DmaPackVif</TT>
<A NAME="marker-803096"></A></P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-803098"></A>Specifies whether a DMA tag will be packed with two subsequent VIF instructions. The argument to <TT CLASS="Code">
.DmaPackVif</TT>
 is either <TT CLASS="Code">
`1'</TT>
 or <TT CLASS="Code">
`0'</TT>
.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId-461623"></A><TT CLASS="Code">
.EndDirect</TT>
<A NAME="marker-524367"></A></P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-462057"></A>Terminates the list of data following <TT CLASS="Code">
direct</TT>
 or <TT CLASS="Code">
directhl</TT>
 VIF opcodes.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId-803109"></A><TT CLASS="Code">
.EndDmaData</TT>
<A NAME="marker-803108"></A></P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-803110"></A>Terminates the list of data following <TT CLASS="Code">
.DmaData</TT>
. </P>
<P CLASS="BodyHang1">
<A NAME="pgfId-461625"></A><TT CLASS="Code">
.EndGif</TT>
<A NAME="marker-515574"></A></P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-462103"></A>Terminates the list of data following <TT CLASS="Code">
GIFpacked</TT>
, <TT CLASS="Code">
GIFreglist</TT>
 and <TT CLASS="Code">
GIFimage</TT>
. </P>
<P CLASS="BodyHang1">
<A NAME="pgfId-529380"></A><TT CLASS="Code">
.endfunc</TT>
<A NAME="marker-529388"></A></P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-529399"></A>Denotes the end of the function started with <TT CLASS="Code">
.func</TT>
.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId-461627"></A><TT CLASS="Code">
.endm</TT>
<A NAME="marker-515575"></A></P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-462112"></A>Terminates a macro definition. </P>
<P CLASS="BodyHang1">
<A NAME="pgfId-461628"></A><TT CLASS="Code">
.EndMpg</TT>
<A NAME="marker-515576"></A></P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-524373"></A>Terminates the list of VU instructions following <TT CLASS="Code">
mpg</TT>
. </P>
<P CLASS="BodyHang1">
<A NAME="pgfId-524375"></A><TT CLASS="Code">
.EndUnpack</TT>
<A NAME="marker-524374"></A></P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-524376"></A>Terminates the list of data following <TT CLASS="Code">
unpack</TT>
. </P>
<P CLASS="BodyHang1">
<A NAME="pgfId-529516"></A><TT CLASS="Code">
.func</TT>
<A NAME="marker-529524"></A></P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-529517"></A>Emits debugging information for user-written assembler functions. Must assemble with <TT CLASS="Code">
--gstabs</TT>
<A NAME="marker-634416"></A> for this directive to have any effect.</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-529518"></A>Syntax:  <TT CLASS="Code">
.func function_name [,symbol_name]</TT>
</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-529416"></A>Note that <TT CLASS="Code">
symbol_name</TT>
 is optional. It is used when the function name, as viewed from the debugger, is different than what is written in the assembler code (for example, some systems have a leading underscore (<TT CLASS="Code">
`_'</TT>
) for C functions).</P>
<P CLASS="BodyHang1">
<A NAME="pgfId-496275"></A><TT CLASS="Code">
.quad</TT>
<A NAME="marker-515578"></A></P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-464193"></A>Assembles a 16-byte integer.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId-495846"></A><TT CLASS="Code">
.vu</TT>
<A NAME="marker-515579"></A></P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-803120"></A>Sets the assembler to compile VU instructions.</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-803121"></A>Must be present before any VU instructions are assembled.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId-495849"></A><TT CLASS="Code">
.word</TT>
<A NAME="marker-515580"></A></P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-495850"></A>Assembles a 4-byte integer.</P>
<H3 CLASS="Heading2">
<A NAME="pgfId-665208"></A><A NAME="marker-803126"></A>VU opcodes </H3>
<P CLASS="Body">
<A NAME="pgfId-803132"></A>For detailed information on the VU machine instruction set, see <STRONG CLASS="BoldEmphasis">
VU Specifications Version 2.10</STRONG>
.</P>
<P CLASS="Body">
<A NAME="pgfId-665210"></A>To set the <TT CLASS="Code">
I, E, M, D</TT>
 and <TT CLASS="Code">
T</TT>
 bits in an instruction, specify the appropriate letters as a bracketed suffix to the upper opcode. Case is ignored.</P>
<P CLASS="Body">
<A NAME="pgfId-528645"></A>For example: </P>
<P CLASS="CodeExample">
<A NAME="pgfId-529037"></A>NOP[DT]     IADDIU  VI01, VI00, LOOP</P>
<H3 CLASS="Heading2">
<A NAME="pgfId-462411"></A><A NAME="marker-803137"></A>VIF opcodes</H3>
<P CLASS="Body">
<A NAME="pgfId-803143"></A>For detailed information on the VIF instruction set, see <STRONG CLASS="BoldEmphasis">
SCEI CPU2 Specifications Version 2.10</STRONG>
. (Note that the &quot;<SPAN CLASS="Bold">
PKE</SPAN>
&quot; has been renamed to &quot;<SPAN CLASS="Bold">
VIF</SPAN>
&quot;.)</P>
<P CLASS="Body">
<A NAME="pgfId-538016"></A>Some tags support the following optional bits, enclosed in brackets &quot;[]&quot; as a suffix:</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-538073"></A><TT CLASS="Code">
i:  interrupt</TT>
</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-538074"></A><TT CLASS="Code">
m:  mask</TT>
 (<TT CLASS="Code">
unpack</TT>
 instruction only)</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-538075"></A><TT CLASS="Code">
r:  TOPS</TT>
 relative address (<TT CLASS="Code">
unpack</TT>
 instruction only)</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-537999"></A><TT CLASS="Code">
u:  </TT>
unsigned <TT CLASS="Code">
UNPACK</TT>
 (<TT CLASS="Code">
unpack</TT>
 instruction only)</P>
<P CLASS="Body">
<A NAME="pgfId-462452"></A>The following instructions are supported:</P>
<P CLASS="BodyHang1List">
<A NAME="pgfId-462747"></A><TT CLASS="Code">
base[i] </TT>
<A NAME="marker-524345"></A><VAR CLASS="CodeVariant">
&lt;expr&gt;</VAR>
</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-462983"></A>Sets the VIF1 Base register. </P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-462989"></A>Notes: </P>
<OL>
<OL>
<LI>
<A NAME="pgfId-463005"></A>Only bits 15:0 of the expression are encoded into the instruction</LI>
<LI>
<A NAME="pgfId-463023"></A>Only bits 9:0 are used by the register. </LI>
</OL>
</OL>
<P CLASS="BodyHang1">
<A NAME="pgfId-464391"></A><TT CLASS="Code">
direct[i] </TT>
<A NAME="marker-524346"></A><VAR CLASS="CodeVariant">
&lt;filename&gt;</VAR>
</P>
<P CLASS="BodyHang1List">
<A NAME="pgfId-464392"></A><TT CLASS="Code">
direct[i] </TT>
<VAR CLASS="CodeVariant">
&lt;expr&gt;</VAR>
</P>
<P CLASS="BodyHang1List">
<A NAME="pgfId-464393"></A><TT CLASS="Code">
direct[i] * </TT>
</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-464394"></A>Send data directly to GIF via path 2. The operand is either the name of a binary file containing only GIF tagged data, or the number of 128-bit quadwords following, or an asterisk for the assembler to compute the number of quadwords following. The last two forms of <TT CLASS="Code">
direct</TT>
 should end the data with the directive <TT CLASS="Code">
.EndDirect</TT>
. Only valid for execution on VIF1. </P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-464564"></A>Examples:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-464650"></A>DIRECT *</P>
<P CLASS="CodeExample">
<A NAME="pgfId-464639"></A>GIFpacked REGS={A_D}, NLOOP=13, EOP</P>
<P CLASS="CodeExample">
<A NAME="pgfId-464626"></A>.int  0x000a0000, 0x00000000, 0x0000004c, 0x00000000</P>
<P CLASS="CodeExample">
<A NAME="pgfId-464661"></A>.int  0x027f0000, 0x01df0000, 0x00000040, 0x00000000</P>
<P CLASS="CodeExample">
<A NAME="pgfId-464668"></A>.int  0x00000001, 0x00000000, 0x0000001a, 0x00000000</P>
<P CLASS="CodeExample">
<A NAME="pgfId-464676"></A>.int  0x01000096, 0x00000000, 0x0000004e, 0x00000000</P>
<P CLASS="CodeExample">
<A NAME="pgfId-464682"></A>.int  0x00000001, 0x00000000, 0x00000046, 0x00000000</P>
<P CLASS="CodeExample">
<A NAME="pgfId-464686"></A>.int  0x00000000, 0x00000000, 0x00000047, 0x00000000</P>
<P CLASS="CodeExample">
<A NAME="pgfId-464692"></A>.int  0x00000000, 0x00000000, 0x00000018, 0x00000000</P>
<P CLASS="CodeExample">
<A NAME="pgfId-464783"></A>.int  0x00000006, 0x00000000, 0x00000000, 0x00000000</P>
<P CLASS="CodeExample">
<A NAME="pgfId-464791"></A>.int  0x00000000, 0x00000000, 0x00000001, 0x00000000</P>
<P CLASS="CodeExample">
<A NAME="pgfId-464797"></A>.int  0x00000000, 0x00000000, 0x00000004, 0x00000000</P>
<P CLASS="CodeExample">
<A NAME="pgfId-464804"></A>.int  0x1e002800, 0x00000000, 0x00000004, 0x00000000</P>
<P CLASS="CodeExample">
<A NAME="pgfId-464815"></A>.int  0x00070000, 0x00000000, 0x00000047, 0x00000000</P>
<P CLASS="CodeExample">
<A NAME="pgfId-501628"></A>.int  0x00006c00, 0x00007100, 0x00000018, 0x00000000</P>
<P CLASS="CodeExample">
<A NAME="pgfId-501629"></A>.EndGif</P>
<P CLASS="CodeExample">
<A NAME="pgfId-501630"></A>.EndDirect</P>
<P CLASS="BodyHang1">
<A NAME="pgfId-464395"></A><TT CLASS="Code">
directhl[i] </TT>
<A NAME="marker-524347"></A><VAR CLASS="CodeVariant">
&lt;filename&gt;</VAR>
</P>
<P CLASS="BodyHang1List">
<A NAME="pgfId-464396"></A><TT CLASS="Code">
directhl[i] </TT>
<VAR CLASS="CodeVariant">
&lt;expr&gt;</VAR>
</P>
<P CLASS="BodyHang1List">
<A NAME="pgfId-464397"></A><TT CLASS="Code">
directhl[i] * </TT>
</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-464398"></A>The syntax of <TT CLASS="Code">
directhl</TT>
 is identical to that of <TT CLASS="Code">
direct.</TT>
 </P>
<P CLASS="BodyHang1">
<A NAME="pgfId-462754"></A><TT CLASS="Code">
flush[i]</TT>
<A NAME="marker-524348"></A> </P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-462755"></A>Waits until the VU1 program and Paths 1 and 2 to GIF are idle. Only valid for execution on VIF1. </P>
<P CLASS="BodyHang1">
<A NAME="pgfId-462758"></A><TT CLASS="Code">
flusha[i]</TT>
<A NAME="marker-524349"></A> </P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-462759"></A>Waits until the VU1 program and all Paths to GIF are idle. Only valid for execution on VIF1. </P>
<P CLASS="BodyHang1">
<A NAME="pgfId-462762"></A><TT CLASS="Code">
flushe[i]</TT>
<A NAME="marker-524350"></A> </P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-462763"></A>Waits until the VU program is idle. </P>
<P CLASS="BodyHang1">
<A NAME="pgfId-462764"></A><TT CLASS="Code">
itop[i] </TT>
<A NAME="marker-524351"></A><VAR CLASS="CodeVariant">
&lt;expr&gt;</VAR>
</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-462765"></A>Sets the VIF ITOPS register. </P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-462766"></A>Notes: </P>
<OL>
<OL>
<LI>
<A NAME="pgfId-462767"></A>Only bits 15:0 of the expression are encoded into the instruction. </LI>
<LI>
<A NAME="pgfId-462768"></A>Only bits 9:0 are used by the register. </LI>
</OL>
</OL>
<P CLASS="BodyHang1">
<A NAME="pgfId-464486"></A><TT CLASS="Code">
mark[i] </TT>
<A NAME="marker-524352"></A><VAR CLASS="CodeVariant">
&lt;abs-expr&gt;</VAR>
 </P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-464487"></A>Sets the VIF Mark register. Only bits 15:0 of the expression are encoded into the instruction. </P>
<P CLASS="BodyHang1">
<A NAME="pgfId-462776"></A><TT CLASS="Code">
mpg[i] </TT>
<A NAME="marker-524354"></A><VAR CLASS="CodeVariant">
&lt;expr&gt;</VAR>
<TT CLASS="Code">
, </TT>
<VAR CLASS="CodeVariant">
&lt;filename&gt;</VAR>
</P>
<P CLASS="BodyHang1List">
<A NAME="pgfId-462777"></A><TT CLASS="Code">
mpg[i] </TT>
<VAR CLASS="CodeVariant">
&lt;expr&gt;</VAR>
<TT CLASS="Code">
, </TT>
<VAR CLASS="CodeVariant">
&lt;expr&gt;</VAR>
</P>
<P CLASS="BodyHang1List">
<A NAME="pgfId-462778"></A><TT CLASS="Code">
mpg[i] </TT>
<VAR CLASS="CodeVariant">
&lt;expr&gt;</VAR>
<TT CLASS="Code">
, *</TT>
 </P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-462779"></A>As <TT CLASS="Code">
flushe,</TT>
 then load a program into micro memory. The first operand is always the address at which to load the program. If specified as &quot;*&quot;, the current value of <TT CLASS="Code">
$.MpgLoc</TT>
 is used. The second operand is either the name of a binary file containing only VU instructions, or the number of following 64-bit doublewords, or an asterisk for the assembler to compute the number of following doublewords. The assembler will automatically insert VIF code (<TT CLASS="Code">
mpg</TT>
, <TT CLASS="Code">
direct</TT>
 or <TT CLASS="Code">
directhl</TT>
) if the written data is longer than the specified length. In addition to assembling the <TT CLASS="Code">
mpg</TT>
 instruction, <TT CLASS="Code">
mpg</TT>
 causes the following to be executed: </P>
<P CLASS="CodeExample">
<A NAME="pgfId-463876"></A>  $.MpgLoc = value of 1st operand ;update the mpg location counter </P>
<P CLASS="CodeExample">
<A NAME="pgfId-463882"></A>  $. = $.MpgLoc ;set the secondary location counter</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-463986"></A>The symbol <TT CLASS="Code">
$.MpgLoc</TT>
 is reserved for the <TT CLASS="Code">
mpg</TT>
 location counter. Users should not set it. The last two forms of <TT CLASS="Code">
mpg</TT>
 should end the VU instructions with the directive <TT CLASS="Code">
.EndMpg</TT>
. It will switch the assembler back to non-VU mode and cause the following to be executed: </P>
<P CLASS="CodeExample2">
<A NAME="pgfId-463987"></A>$.MpgLoc = $. ;update the mpg location counter</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-463988"></A>Examples: </P>
<P CLASS="CodeExample">
<A NAME="pgfId-462798"></A>        mpg 0x20,&quot;test00.vubin&quot; </P>
<P CLASS="CodeExample">
<A NAME="pgfId-462799"></A>        mpg *,*</P>
<P CLASS="CodeExample">
<A NAME="pgfId-569996"></A>main:   NOP IADDIU VI01,VI00,0 ;Euler angle,transfer vector</P>
<P CLASS="CodeExample">
<A NAME="pgfId-569997"></A>        NOP IADDIU VI02,VI00,22 ; omatrix(SCREEN/LOCAL)</P>
<P CLASS="CodeExample">
<A NAME="pgfId-569998"></A>        NOP NOP </P>
<P CLASS="CodeExample">
<A NAME="pgfId-462803"></A>        NOP BAL VI15,$RotMatrix </P>
<P CLASS="CodeExample">
<A NAME="pgfId-462804"></A>        NOP NOP </P>
<P CLASS="CodeExample">
<A NAME="pgfId-462805"></A>        NOP END ;wait VIF </P>
<P CLASS="CodeExample">
<A NAME="pgfId-462806"></A>        NOP NOP </P>
<P CLASS="CodeExample">
<A NAME="pgfId-462807"></A>        NOP B $main ;repeat </P>
<P CLASS="CodeExample">
<A NAME="pgfId-462808"></A>        NOP NOP </P>
<P CLASS="CodeExample">
<A NAME="pgfId-464234"></A>        .EndMpg</P>
<P CLASS="BodyHang1">
<A NAME="pgfId-789680"></A><TT CLASS="Code">
mscal[i] </TT>
<A NAME="marker-789679"></A><VAR CLASS="CodeVariant">
&lt;expr&gt;</VAR>
</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-789681"></A>As <TT CLASS="Code">
flushe,</TT>
 then sets the VU1 start address to <VAR CLASS="CodeVariant">
&lt;expr&gt; </VAR>
and executes via <TT CLASS="Code">
callms.</TT>
</P>
<P CLASS="BodyHang1">
<A NAME="pgfId-464531"></A><TT CLASS="Code">
mscalf[i] </TT>
<A NAME="marker-524356"></A><VAR CLASS="CodeVariant">
&lt;expr&gt;</VAR>
<TT CLASS="Code">
 </TT>
</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-464532"></A>As <TT CLASS="Code">
flush,</TT>
 then sets the VU1 start address to <VAR CLASS="CodeVariant">
&lt;expr&gt; </VAR>
and executes via <TT CLASS="Code">
callms.</TT>
</P>
<P CLASS="BodyHang1">
<A NAME="pgfId-464533"></A><TT CLASS="Code">
mscnt[i]</TT>
<A NAME="marker-524357"></A> </P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-464534"></A>As <TT CLASS="Code">
flushe, </TT>
then continues to execute a micro program from the next address of the last program counter on VU. </P>
<P CLASS="BodyHang1">
<A NAME="pgfId-532950"></A><TT CLASS="Code">
mskpath3[i] </TT>
<A NAME="marker-532949"></A><VAR CLASS="CodeVariant">
&lt;ability&gt;</VAR>
</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-532951"></A>Enables or disables path 3 transfers. </P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-532952"></A>Notes: </P>
<OL>
<OL>
<LI>
<A NAME="pgfId-740000"></A>Bit 15 of the instruction is set via <VAR CLASS="CodeVariant">
&lt;ability&gt;</VAR>
</LI>
</OL>
</OL>
<P CLASS="BodyListFollow3">
<A NAME="pgfId-532955"></A>     DISABLE = 1 AND ENABLE = 0. </P>
<OL>
<OL>
<LI>
<A NAME="pgfId-740002"></A>Bits 14:0 are always set to 0. </LI>
<LI>
<A NAME="pgfId-803193"></A>Only valid for execution on VIF1.</LI>
</OL>
</OL>
<P CLASS="BodyHang1">
<A NAME="pgfId-464298"></A><TT CLASS="Code">
offset[i] </TT>
<A NAME="marker-524358"></A><VAR CLASS="CodeVariant">
&lt;expr&gt;</VAR>
</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-464299"></A>Sets the VIF1 Offset register. </P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-464300"></A>Notes: </P>
<OL>
<OL>
<LI>
<A NAME="pgfId-740024"></A>Only bits 15:0 of the expression are encoded into the instruction.</LI>
<LI>
<A NAME="pgfId-740025"></A>Only bits 9:0 are used by the register. </LI>
</OL>
</OL>
<P CLASS="BodyHang1">
<A NAME="pgfId-740027"></A><TT CLASS="Code">
stcol[i] </TT>
<A NAME="marker-740026"></A><VAR CLASS="CodeVariant">
&lt;expr0&gt;</VAR>
<TT CLASS="Code">
, </TT>
<VAR CLASS="CodeVariant">
&lt;expr1&gt;</VAR>
<TT CLASS="Code">
, </TT>
<VAR CLASS="CodeVariant">
&lt;expr2&gt;</VAR>
<TT CLASS="Code">
, </TT>
<VAR CLASS="CodeVariant">
&lt;expr3&gt;</VAR>
 </P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-464326"></A>Set the VIF <TT CLASS="Code">
COL</TT>
 registers <TT CLASS="Code">
C0, C1, C2</TT>
 and <TT CLASS="Code">
C3</TT>
. All 32-bits are used from each expression. </P>
<P CLASS="BodyHang1">
<A NAME="pgfId-462842"></A><TT CLASS="Code">
stcycl[i] </TT>
<A NAME="marker-524360"></A><VAR CLASS="CodeVariant">
&lt;abs-expr&gt;</VAR>
<TT CLASS="Code">
, </TT>
<VAR CLASS="CodeVariant">
&lt;abs-expr&gt;</VAR>
 </P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-462843"></A>Sets the VIF <TT CLASS="Code">
WL</TT>
 and <TT CLASS="Code">
CL</TT>
 values in the cycle register from the 1st and 2nd operands, respectively. Only bits 7:0 are used from each expression. </P>
<P CLASS="BodyHang1">
<A NAME="pgfId-665282"></A><TT CLASS="Code">
stmask[i] </TT>
<A NAME="marker-665281"></A><VAR CLASS="CodeVariant">
&lt;expr&gt;</VAR>
<TT CLASS="Code">
 </TT>
</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-665283"></A>Sets VIF <TT CLASS="Code">
MASK</TT>
 register to <VAR CLASS="CodeVariant">
&lt;expr&gt;.</VAR>
 All 32 bits are used. </P>
<P CLASS="BodyHang1">
<A NAME="pgfId-665285"></A><TT CLASS="Code">
stmod[i] </TT>
<A NAME="marker-665284"></A><VAR CLASS="CodeVariant">
&lt;mode&gt;</VAR>
<TT CLASS="Code">
 </TT>
</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-462846"></A>Sets the VIF <TT CLASS="Code">
MODE</TT>
 register, where <VAR CLASS="CodeVariant">
&lt;mode&gt;</VAR>
  is one of <TT CLASS="Code">
DIRECT, ADD,</TT>
 or <TT CLASS="Code">
ADDROW.</TT>
 </P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-462847"></A>Notes: </P>
<OL>
<OL>
<LI>
<A NAME="pgfId-462848"></A>Bits 15:2 of the instruction are always set to 0. </LI>
<LI>
<A NAME="pgfId-462849"></A>Bits 1:0 are set via <VAR CLASS="CodeVariant">
&lt;mode&gt;</VAR>
<TT CLASS="Code">
: DIRECT = 0x00, ADD = 0x01, and ADDROW = 0x02</TT>
 </LI>
</OL>
</OL>
<P CLASS="BodyHang1">
<A NAME="pgfId-535866"></A><TT CLASS="Code">
strow[i] </TT>
<A NAME="marker-524363"></A><VAR CLASS="CodeVariant">
&lt;expr0&gt;</VAR>
<TT CLASS="Code">
, </TT>
<VAR CLASS="CodeVariant">
&lt;expr1&gt;</VAR>
<TT CLASS="Code">
, </TT>
<VAR CLASS="CodeVariant">
&lt;expr2&gt;</VAR>
<TT CLASS="Code">
, </TT>
<VAR CLASS="CodeVariant">
&lt;expr3&gt;</VAR>
 </P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-462856"></A>Sets the VIF <TT CLASS="Code">
ROW</TT>
 registers <TT CLASS="Code">
R0</TT>
, <TT CLASS="Code">
R1</TT>
, <TT CLASS="Code">
R2</TT>
 and <TT CLASS="Code">
R3</TT>
. All 32 bits are used from each expression.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId-464949"></A><TT CLASS="Code">
unpack[imru] </TT>
<A NAME="marker-524364"></A><VAR CLASS="CodeVariant">
&lt;wl&gt;</VAR>
<TT CLASS="Code">
, </TT>
<VAR CLASS="CodeVariant">
&lt;cl&gt;</VAR>
<TT CLASS="Code">
, </TT>
<VAR CLASS="CodeVariant">
&lt;type&gt;</VAR>
<TT CLASS="Code">
, </TT>
<VAR CLASS="CodeVariant">
&lt;addr&gt;</VAR>
<TT CLASS="Code">
, &lt;filename&gt; </TT>
</P>
<P CLASS="BodyHang1List">
<A NAME="pgfId-464950"></A><TT CLASS="Code">
unpack[imru] </TT>
<VAR CLASS="CodeVariant">
&lt;wl&gt;</VAR>
<TT CLASS="Code">
, </TT>
<VAR CLASS="CodeVariant">
&lt;cl&gt;</VAR>
<TT CLASS="Code">
, </TT>
<VAR CLASS="CodeVariant">
&lt;type&gt;</VAR>
<TT CLASS="Code">
, </TT>
<VAR CLASS="CodeVariant">
&lt;addr&gt;</VAR>
<TT CLASS="Code">
, *</TT>
 </P>
<P CLASS="BodyHang1List">
<A NAME="pgfId-665306"></A><TT CLASS="Code">
unpack[imru] </TT>
<VAR CLASS="CodeVariant">
&lt;wl&gt;</VAR>
<TT CLASS="Code">
, </TT>
<VAR CLASS="CodeVariant">
&lt;cl&gt;</VAR>
<TT CLASS="Code">
, </TT>
<VAR CLASS="CodeVariant">
&lt;type&gt;</VAR>
<TT CLASS="Code">
, </TT>
<VAR CLASS="CodeVariant">
&lt;addr&gt;</VAR>
<TT CLASS="Code">
, </TT>
<VAR CLASS="CodeVariant">
&lt;num&gt;</VAR>
 </P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-665307"></A>Unpack data to an address in VU memory according to type. </P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-665308"></A>The above forms emit two machine instructions. The first, <TT CLASS="Code">
stcycl,</TT>
 sets the VIF <TT CLASS="Code">
WL</TT>
 and <TT CLASS="Code">
CL</TT>
 values in the cycle register from the 1st and 2nd operands, respectively. The second, <TT CLASS="Code">
unpack,</TT>
 uses the remaining operands. These instructions are emitted together because assembling the unpack instruction requires knowledge of the <TT CLASS="Code">
WL</TT>
 and <TT CLASS="Code">
CL</TT>
 values.</P>
<P CLASS="Body">
<A NAME="pgfId-535956"></A>The following forms are deprecated, and assume the <TT CLASS="Code">
WL</TT>
 and <TT CLASS="Code">
CL</TT>
 values from the most recently assembled <TT CLASS="Code">
stcycl</TT>
 instruction:</P>
<P CLASS="BodyHang1">
<A NAME="pgfId-535957"></A><TT CLASS="Code">
unpack[imru] </TT>
<VAR CLASS="CodeVariant">
&lt;type&gt;</VAR>
<TT CLASS="Code">
, </TT>
<VAR CLASS="CodeVariant">
&lt;addr&gt;</VAR>
<TT CLASS="Code">
, </TT>
<VAR CLASS="CodeVariant">
&lt;filename&gt;</VAR>
</P>
<P CLASS="BodyHang1List">
<A NAME="pgfId-535958"></A><TT CLASS="Code">
unpack[imru] </TT>
<VAR CLASS="CodeVariant">
&lt;type&gt;</VAR>
<TT CLASS="Code">
, </TT>
<VAR CLASS="CodeVariant">
&lt;addr&gt;</VAR>
<TT CLASS="Code">
, *</TT>
 </P>
<P CLASS="BodyHang1List">
<A NAME="pgfId-464940"></A><TT CLASS="Code">
unpack[imru] </TT>
<VAR CLASS="CodeVariant">
&lt;type&gt;</VAR>
<TT CLASS="Code">
, </TT>
<VAR CLASS="CodeVariant">
&lt;addr&gt;</VAR>
<TT CLASS="Code">
, </TT>
<VAR CLASS="CodeVariant">
&lt;num&gt;</VAR>
 </P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-462881"></A>Unpack data to an address in VU memory according to type. The <VAR CLASS="CodeVariant">
&lt;type&gt;</VAR>
 operand is the type of data. </P>
<P CLASS="BodyListFollow2">
<A NAME="pgfId-462883"></A><TT CLASS="Code">
S_32 scalar, 32-bit </TT>
</P>
<P CLASS="BodyListFollow2">
<A NAME="pgfId-462884"></A><TT CLASS="Code">
S_16 scalar, 16-bit </TT>
</P>
<P CLASS="BodyListFollow2">
<A NAME="pgfId-462885"></A><TT CLASS="Code">
S_8 scalar, 8-bit </TT>
</P>
<P CLASS="BodyListFollow2">
<A NAME="pgfId-462886"></A><TT CLASS="Code">
V2_32 vector of 2 * 32-bit </TT>
</P>
<P CLASS="BodyListFollow2">
<A NAME="pgfId-462887"></A><TT CLASS="Code">
V2_16 vector of 2 * 16-bit </TT>
</P>
<P CLASS="BodyListFollow2">
<A NAME="pgfId-462888"></A><TT CLASS="Code">
V2_8 vector of 2 * 8-bit </TT>
</P>
<P CLASS="BodyListFollow2">
<A NAME="pgfId-462889"></A><TT CLASS="Code">
V3_32 vector of 3 * 32-bit </TT>
</P>
<P CLASS="BodyListFollow2">
<A NAME="pgfId-462890"></A><TT CLASS="Code">
V3_16 vector of 3 * 16-bit </TT>
</P>
<P CLASS="BodyListFollow2">
<A NAME="pgfId-462891"></A><TT CLASS="Code">
V3_8 vector of 3 * 8-bit </TT>
</P>
<P CLASS="BodyListFollow2">
<A NAME="pgfId-462892"></A><TT CLASS="Code">
V4_32 vector of 4 * 32-bit </TT>
</P>
<P CLASS="BodyListFollow2">
<A NAME="pgfId-462893"></A><TT CLASS="Code">
V4_16 vector of 4 * 16-bit </TT>
</P>
<P CLASS="BodyListFollow2">
<A NAME="pgfId-462894"></A><TT CLASS="Code">
V4_8 vector of 4 * 8-bit </TT>
</P>
<P CLASS="BodyListFollow2">
<A NAME="pgfId-462895"></A><TT CLASS="Code">
V4_5 vector of 4 * 5-bit </TT>
(actually <TT CLASS="Code">
1*1-bit</TT>
 and <TT CLASS="Code">
3*5-bit</TT>
)</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-462896"></A>The <VAR CLASS="CodeVariant">
&lt;addr&gt;</VAR>
 operand is always the address at which to load the data. The final operand is either the name of a binary file containing only data, or an asterisk for the assembler to compute the number of data writes to be performed. </P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-465045"></A>A <TT CLASS="Code">
PackV4_5</TT>
 macro will be provided to encode the <TT CLASS="Code">
V4_5</TT>
 packed data for this instruction. An example of its use is: </P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-465060"></A>Examples:</P>
<P CLASS="CodeExample2">
<A NAME="pgfId-462906"></A>Unpack 1, 1, V4_5, loadAddr, * </P>
<P CLASS="CodeExample2">
<A NAME="pgfId-462907"></A>PackV4_5 1,29,7,12 </P>
<P CLASS="CodeExample2">
<A NAME="pgfId-462908"></A>PackV4_5 0,18,31,4 </P>
<P CLASS="CodeExample2">
<A NAME="pgfId-462909"></A>.EndUnpack</P>
<P CLASS="CodeExample2">
<A NAME="pgfId-462924"></A>&nbsp;</P>
<P CLASS="CodeExample2">
<A NAME="pgfId-465073"></A>unpack 1, 1, V4_32, loadAddr, &quot;euler.vubin&quot; </P>
<P CLASS="CodeExample2">
<A NAME="pgfId-462925"></A>unpack 1, 1, V4_32, 0X20, * </P>
<P CLASS="CodeExample2">
<A NAME="pgfId-462926"></A>.float   0,   -0.7, 0,  0.7 ; Euler angle (sin) </P>
<P CLASS="CodeExample2">
<A NAME="pgfId-462927"></A>.float   0,   -0.7, 0, -0.7 ; Euler angle (cos) </P>
<P CLASS="CodeExample2">
<A NAME="pgfId-462928"></A>.float 1.0, 1024.0, 0,    0 ; Transfer vector </P>
<P CLASS="CodeExample2">
<A NAME="pgfId-463673"></A>.EndUnpack </P>
<P CLASS="CodeExample2">
<A NAME="pgfId-463674"></A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId-611579"></A>&nbsp;</P>
<P CLASS="CodeExample2">
<A NAME="pgfId-463675"></A>unpack 1, 1, V3_8, 0X40, * </P>
<P CLASS="CodeExample2">
<A NAME="pgfId-462932"></A>.byte 0x00, 0x10, 0x20 </P>
<P CLASS="CodeExample2">
<A NAME="pgfId-462933"></A>.byte 0x30, 0x40, 0x50 </P>
<P CLASS="CodeExample2">
<A NAME="pgfId-462742"></A>.EndUnpack </P>
<P CLASS="BodyHang1">
<A NAME="pgfId-464217"></A><TT CLASS="Code">
vifnop[i]</TT>
<A NAME="marker-524365"></A> </P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-464218"></A>VIF no-op instruction. </P>
<H3 CLASS="Heading2">
<A NAME="pgfId-803244"></A><A NAME="marker-803243"></A>DMA tag instructions</H3>
<P CLASS="Body">
<A NAME="pgfId-803245"></A>&quot;Source&quot; DMA (from memory) is done by one of eight DMA tags:</P>
<P CLASS="BodyHang1">
<A NAME="pgfId-803247"></A><TT CLASS="Code">
DMAcnt</TT>
<A NAME="marker-803246"></A> </P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-803248"></A>Inline data, inline next-tag</P>
<P CLASS="BodyHang1">
<A NAME="pgfId-803250"></A><TT CLASS="Code">
DMAnext</TT>
<A NAME="marker-803249"></A> </P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-803251"></A>Inline data, ptr to next-tag</P>
<P CLASS="BodyHang1">
<A NAME="pgfId-803253"></A><TT CLASS="Code">
DMAref</TT>
<A NAME="marker-803252"></A> </P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-803254"></A><TT CLASS="Code">
ptr</TT>
 to data, inline next-tag</P>
<P CLASS="BodyHang1">
<A NAME="pgfId-803256"></A><TT CLASS="Code">
DMArefe</TT>
<A NAME="marker-803255"></A></P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-803257"></A><TT CLASS="Code">
ptr</TT>
 to data, inline next-tag and stop</P>
<P CLASS="BodyHang1">
<A NAME="pgfId-803259"></A><TT CLASS="Code">
DMArefs</TT>
<A NAME="marker-803258"></A> </P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-803260"></A><TT CLASS="Code">
ptr</TT>
 to data, inline next-tag (stall control)</P>
<P CLASS="BodyHang1">
<A NAME="pgfId-803262"></A><TT CLASS="Code">
DMAcall</TT>
<A NAME="marker-803261"></A> </P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-803263"></A>Inline data, ptr to next-tag (push <TT CLASS="Code">
addr</TT>
 of inline tag)</P>
<P CLASS="BodyHang1">
<A NAME="pgfId-803265"></A><TT CLASS="Code">
DMAret</TT>
<A NAME="marker-803264"></A> </P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-803266"></A>Inline data, pop next-tag <TT CLASS="Code">
addr</TT>
</P>
<P CLASS="BodyHang1">
<A NAME="pgfId-803268"></A><TT CLASS="Code">
DMAend</TT>
<A NAME="marker-803267"></A> </P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-803269"></A>Inline data and stop</P>
<P CLASS="Body">
<A NAME="pgfId-803270"></A>&quot;Destination&quot; DMA (to memory) is not supported.</P>
<P CLASS="Body">
<A NAME="pgfId-803271"></A>Each tag supports the following optional bits, enclosed in brackets &quot;[]&quot; as a suffix:</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-803272"></A><TT CLASS="Code">
0   </TT>
D_PCR.PCE=0</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-803273"></A><TT CLASS="Code">
1   </TT>
D_PCR.PCE=1</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-803274"></A><TT CLASS="Code">
I   </TT>
Interrupt request</P>
<P CLASS="BodyListFollow">
<A NAME="pgfId-803275"></A><TT CLASS="Code">
S   </TT>
SPR address (N/A for DMA channels 0, 1, 2)</P>
<P CLASS="Body">
<A NAME="pgfId-803276"></A>Most tags have two operands: a quadword count and address. For <TT CLASS="Code">
DMAcnt</TT>
, <TT CLASS="Code">
DMAret</TT>
 and <TT CLASS="Code">
DMAend</TT>
 the second operand is not permitted.</P>
<P CLASS="Body">
<A NAME="pgfId-803277"></A>The DMA tags may be coded in one of two forms:</P>
<P CLASS="BodyHang2">
<A NAME="pgfId-803278"></A><TT CLASS="Code">
*, DmaData_label</TT>
</P>
<P CLASS="BodyListFollow2">
<A NAME="pgfId-803279"></A>The asterisk indicates that the quadword count should be taken from the attributes of the label on a <TT CLASS="Code">
DmaData</TT>
 macro.</P>
<P CLASS="BodyHang2">
<A NAME="pgfId-803280"></A><TT CLASS="Code">
QWcount, address</TT>
</P>
<P CLASS="BodyListFollow2">
<A NAME="pgfId-803281"></A>The quadword count is specified along with the address or label of the data block.</P>
<P CLASS="Body">
<A NAME="pgfId-803282"></A>Since DMA tags must be 16-byte aligned but are only 8 bytes long, the hardware supports packing two VIF instructions into the unused upper words. By default, the assembler will automatically pack the next two instructions into a DMA tag if they are VIF instructions. This behavior can be disabled by <TT CLASS="Code">
.DmaPackVif 0</TT>
 or re-enabled with <TT CLASS="Code">
.DmaPackVif 1.</TT>
</P>
<P CLASS="Body">
<A NAME="pgfId-803283"></A>If the assembler is not filling the unused upper words with subsequent VIF instructions, they will be set to VIF <TT CLASS="Code">
NOP</TT>
 instructions.</P>
<P CLASS="Body">
<A NAME="pgfId-803284"></A>Examples of how to use DMA tags:</P>
<P CLASS="CodeExample">
<A NAME="pgfId-803285"></A>DMAref[I1] *, data1</P>
<P CLASS="CodeExample">
<A NAME="pgfId-803286"></A>DMAend  4</P>
<P CLASS="CodeExample">
<A NAME="pgfId-803287"></A>.word   0, 0, 0, 0</P>
<P CLASS="CodeExample">
<A NAME="pgfId-803288"></A>.EndDmaData</P>
<P CLASS="CodeExample">
<A NAME="pgfId-803289"></A>&nbsp;</P>
<P CLASS="CodeExample">
<A NAME="pgfId-803290"></A>.DmaData data1</P>
<P CLASS="CodeExample">
<A NAME="pgfId-803291"></A>MPG     *, *</P>
<P CLASS="CodeExample">
<A NAME="pgfId-803292"></A>NOP     IADDIU  VI01, VI00, 0x00000100</P>
<P CLASS="CodeExample">
<A NAME="pgfId-803293"></A>NOP     LQI.xyzw VF04, (VI01++) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-803294"></A>NOP[d]  LQI.xyzw VF05, (VI01++) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-803295"></A>NOP     LQI.xyzw VF06, (VI01++) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-803296"></A>NOP     LQI.xyzw VF07, (VI01++) </P>
<P CLASS="CodeExample">
<A NAME="pgfId-803297"></A>NOP[e]  NOP</P>
<P CLASS="CodeExample">
<A NAME="pgfId-803298"></A>NOP     NOP</P>
<P CLASS="CodeExample">
<A NAME="pgfId-803299"></A>.endmpg</P>
<P CLASS="CodeExample">
<A NAME="pgfId-803300"></A>.EndDmaData</P>
<H3 CLASS="Heading2">
<A NAME="pgfId-462743"></A><A NAME="marker-516757"></A>GIF tag instructions</H3>
<P CLASS="Body">
<A NAME="pgfId-489345"></A>There are three forms of the GIF tag: <TT CLASS="Code">
PACKED</TT>
, <TT CLASS="Code">
REGLIST</TT>
 and <TT CLASS="Code">
IMAGE</TT>
.</P>
<P CLASS="BodyHang1">
<A NAME="pgfId-489346"></A><TT CLASS="Code">
GIFpacked  PRIM=0Xxx, REGS={ rr, rr, ..}, NLOOP=c, EOP</TT>
<A NAME="marker-516748"></A></P>
<P CLASS="BodyHang2">
<A NAME="pgfId-489348"></A><TT CLASS="Code">
PRIM</TT>
</P>
<P CLASS="BodyListFollow2">
<A NAME="pgfId-489349"></A>Optional.</P>
<P CLASS="BodyListFollow2">
<A NAME="pgfId-489350"></A>The least-significant 11 bits will be transferred to the <TT CLASS="Code">
PRIM</TT>
 register. The other bits are ignored.</P>
<P CLASS="BodyHang2">
<A NAME="pgfId-489351"></A><TT CLASS="Code">
REGS</TT>
</P>
<P CLASS="BodyListFollow2">
<A NAME="pgfId-489641"></A>Required. </P>
<P CLASS="BodyListFollow2">
<A NAME="pgfId-489353"></A>One to sixteen instances of the following register names may be specified in any order, combination or repetitions.</P>
<P CLASS="BodyListFollow2">
<A NAME="pgfId-489356"></A>The sixteen possible register names and encodings are:</P>
<P CLASS="BodyListFollow3">
<A NAME="pgfId-489357"></A><TT CLASS="Code">
0x0 PRIM</TT>
</P>
<P CLASS="BodyListFollow3">
<A NAME="pgfId-489358"></A><TT CLASS="Code">
0x1 RGBAQ</TT>
</P>
<P CLASS="BodyListFollow3">
<A NAME="pgfId-489359"></A><TT CLASS="Code">
0x2 ST</TT>
</P>
<P CLASS="BodyListFollow3">
<A NAME="pgfId-489360"></A><TT CLASS="Code">
0x3 UV</TT>
</P>
<P CLASS="BodyListFollow3">
<A NAME="pgfId-489361"></A><TT CLASS="Code">
0x4 XYZF2</TT>
</P>
<P CLASS="BodyListFollow3">
<A NAME="pgfId-489362"></A><TT CLASS="Code">
0x5 XYZ2</TT>
</P>
<P CLASS="BodyListFollow3">
<A NAME="pgfId-489363"></A><TT CLASS="Code">
0x6 TEX0_1</TT>
</P>
<P CLASS="BodyListFollow3">
<A NAME="pgfId-489364"></A><TT CLASS="Code">
0x7 TEX0_2</TT>
</P>
<P CLASS="BodyListFollow3">
<A NAME="pgfId-489365"></A><TT CLASS="Code">
0x8 CLAMP_1</TT>
</P>
<P CLASS="BodyListFollow3">
<A NAME="pgfId-489366"></A><TT CLASS="Code">
0x9 CLAMP_2</TT>
</P>
<P CLASS="BodyListFollow3">
<A NAME="pgfId-489367"></A><TT CLASS="Code">
0xA XYZF</TT>
</P>
<P CLASS="BodyListFollow3">
<A NAME="pgfId-489368"></A><TT CLASS="Code">
0xB RESERVED</TT>
</P>
<P CLASS="BodyListFollow3">
<A NAME="pgfId-489369"></A><TT CLASS="Code">
0xC XYZF3</TT>
</P>
<P CLASS="BodyListFollow3">
<A NAME="pgfId-489370"></A><TT CLASS="Code">
0xD XYZ3</TT>
</P>
<P CLASS="BodyListFollow3">
<A NAME="pgfId-489371"></A><TT CLASS="Code">
0xE A_D</TT>
</P>
<P CLASS="BodyListFollow3">
<A NAME="pgfId-489372"></A><TT CLASS="Code">
0xF NOP </TT>
(skips a quadword of data)</P>
<P CLASS="BodyHang2">
<A NAME="pgfId-489374"></A><TT CLASS="Code">
NLOOP</TT>
</P>
<P CLASS="BodyListFollow2">
<A NAME="pgfId-489375"></A>Optional. If unspecified, its value is computed from the location of <TT CLASS="Code">
.EndGif.</TT>
</P>
<P CLASS="BodyListFollow2">
<A NAME="pgfId-489376"></A>The least-significant 15 bits are used as an iteration count for the list of registers. The length of the following data must be <TT CLASS="Code">
NREG*NLOOP</TT>
 quadwords.</P>
<P CLASS="BodyHang2">
<A NAME="pgfId-490881"></A><TT CLASS="Code">
EOP</TT>
</P>
<P CLASS="BodyListFollow2">
<A NAME="pgfId-489378"></A>Optional.</P>
<P CLASS="BodyListFollow2">
<A NAME="pgfId-489379"></A>If specified, there is no subsequent primitive in this packet </P>
<P CLASS="BodyListFollow2">
<A NAME="pgfId-489380"></A>(End-Of-Packet).</P>
<P CLASS="BodyHang2">
<A NAME="pgfId-489744"></A>Note:</P>
<OL>
<OL>
<LI>
<A NAME="pgfId-489382"></A>If both <TT CLASS="Code">
PRIM</TT>
 and <TT CLASS="Code">
REGS</TT>
 are given, the <TT CLASS="Code">
PRIM</TT>
 value is transferred first.</LI>
<LI>
<A NAME="pgfId-528085"></A>The assembler will produce a warning if the length of the following data is not <TT CLASS="Code">
NREG*NLOOP</TT>
 128-bit quadwords.</LI>
<LI>
<A NAME="pgfId-528078"></A>The tag and any data must be followed by the pseudo-op <TT CLASS="Code">
.EndGif.</TT>
</LI>
</OL>
</OL>
<P CLASS="BodyHang1">
<A NAME="pgfId-489787"></A><TT CLASS="Code">
GIFreglist  REGS={ rr, rr, ..}, NLOOP=c, EOP</TT>
<A NAME="marker-516749"></A></P>
<P CLASS="BodyHang2">
<A NAME="pgfId-489390"></A><TT CLASS="Code">
REGS</TT>
</P>
<P CLASS="BodyListFollow2">
<A NAME="pgfId-489391"></A>Required.</P>
<P CLASS="BodyListFollow2">
<A NAME="pgfId-489392"></A>One to sixteen instances of the following register names may be specified in any order, combination or repetitions.</P>
<P CLASS="BodyListFollow2">
<A NAME="pgfId-489395"></A>The sixteen possible register names and encodings are:</P>
<P CLASS="BodyListFollow3">
<A NAME="pgfId-489396"></A><TT CLASS="Code">
0x0 PRIM</TT>
</P>
<P CLASS="BodyListFollow3">
<A NAME="pgfId-489397"></A><TT CLASS="Code">
0x1 RGBAQ</TT>
</P>
<P CLASS="BodyListFollow3">
<A NAME="pgfId-489398"></A><TT CLASS="Code">
0x2 ST</TT>
</P>
<P CLASS="BodyListFollow3">
<A NAME="pgfId-489399"></A><TT CLASS="Code">
0x3 UV</TT>
</P>
<P CLASS="BodyListFollow3">
<A NAME="pgfId-489400"></A><TT CLASS="Code">
0x4 XYZF2</TT>
</P>
<P CLASS="BodyListFollow3">
<A NAME="pgfId-489401"></A><TT CLASS="Code">
0x5 XYZ2</TT>
</P>
<P CLASS="BodyListFollow3">
<A NAME="pgfId-489402"></A><TT CLASS="Code">
0x6 TEX0_1</TT>
</P>
<P CLASS="BodyListFollow3">
<A NAME="pgfId-489403"></A><TT CLASS="Code">
0x7 TEX0_2</TT>
</P>
<P CLASS="BodyListFollow3">
<A NAME="pgfId-489404"></A><TT CLASS="Code">
0x8 CLAMP_1</TT>
</P>
<P CLASS="BodyListFollow3">
<A NAME="pgfId-489405"></A><TT CLASS="Code">
0x9 CLAMP_2</TT>
</P>
<P CLASS="BodyListFollow3">
<A NAME="pgfId-489406"></A><TT CLASS="Code">
0xA XYZF</TT>
</P>
<P CLASS="BodyListFollow3">
<A NAME="pgfId-489407"></A><TT CLASS="Code">
0xB RESERVED</TT>
</P>
<P CLASS="BodyListFollow3">
<A NAME="pgfId-489408"></A><TT CLASS="Code">
0xC XYZF3</TT>
</P>
<P CLASS="BodyListFollow3">
<A NAME="pgfId-489409"></A><TT CLASS="Code">
0xD XYZ3</TT>
</P>
<P CLASS="BodyListFollow3">
<A NAME="pgfId-489410"></A><TT CLASS="Code">
0xE A_D</TT>
</P>
<P CLASS="BodyListFollow3">
<A NAME="pgfId-489411"></A><TT CLASS="Code">
0xF NOP </TT>
(skips 64 bits of data)</P>
<P CLASS="BodyHang2">
<A NAME="pgfId-489414"></A><TT CLASS="Code">
NLOOP</TT>
</P>
<P CLASS="BodyListFollow2">
<A NAME="pgfId-489415"></A>Optional. If unspecified, its value is computed from the location of <TT CLASS="Code">
.EndGif.</TT>
</P>
<P CLASS="BodyListFollow2">
<A NAME="pgfId-489416"></A>The least-significant 15 bits are used as an iteration count for the list of registers.</P>
<P CLASS="BodyHang2">
<A NAME="pgfId-489417"></A><TT CLASS="Code">
EOP</TT>
</P>
<P CLASS="BodyListFollow2">
<A NAME="pgfId-489418"></A>Optional.</P>
<P CLASS="BodyListFollow2">
<A NAME="pgfId-489419"></A>If specified, there is no subsequent primitive in this packet </P>
<P CLASS="BodyListFollow2">
<A NAME="pgfId-489420"></A>(End-Of-Packet).</P>
<P CLASS="BodyHang2">
<A NAME="pgfId-489421"></A>Notes:</P>
<OL>
<OL>
<LI>
<A NAME="pgfId-489422"></A>The length of subsequent data must be <TT CLASS="Code">
NREG*NLOOP</TT>
 64-bit words.</LI>
<LI>
<A NAME="pgfId-489423"></A>The data is contained in quadwords. If the number of 64-bit words is odd, the most-significant 64-bits of the last quadword are ignored.</LI>
<LI>
<A NAME="pgfId-489424"></A>The data must be followed by the pseudo-op <TT CLASS="Code">
.EndGif.</TT>
</LI>
</OL>
</OL>
<P CLASS="BodyHang1">
<A NAME="pgfId-489426"></A><TT CLASS="Code">
GIFimage  NLOOP=c, EOP</TT>
<A NAME="marker-516750"></A></P>
<P CLASS="BodyHang2">
<A NAME="pgfId-489429"></A><TT CLASS="Code">
NLOOP</TT>
</P>
<P CLASS="BodyListFollow2">
<A NAME="pgfId-489430"></A>Optional. If unspecified, its value is computed from the location of <TT CLASS="Code">
.EndGif.</TT>
</P>
<P CLASS="BodyListFollow2">
<A NAME="pgfId-489431"></A>The least-significant 15 bits are used as an count of the number of data values to be transferred to <TT CLASS="Code">
HWREG (0x54).</TT>
</P>
<P CLASS="BodyHang2">
<A NAME="pgfId-489432"></A><TT CLASS="Code">
EOP</TT>
</P>
<P CLASS="BodyListFollow2">
<A NAME="pgfId-489433"></A>Optional.</P>
<P CLASS="BodyListFollow2">
<A NAME="pgfId-489434"></A>If specified, there is no subsequent primitive in this packet</P>
<P CLASS="BodyListFollow2">
<A NAME="pgfId-489435"></A>(End-Of-Packet).</P>
<P CLASS="BodyHang2">
<A NAME="pgfId-489436"></A>Notes:</P>
<OL>
<OL>
<LI>
<A NAME="pgfId-489437"></A>The length of subsequent data must be <TT CLASS="Code">
NLOOP</TT>
 128-bit quadwords.</LI>
<LI>
<A NAME="pgfId-490139"></A>The data must be followed by the pseudo-op <TT CLASS="Code">
.EndGif.</TT>
</LI>
</OL>
</OL>
<HR ALIGN="center">
<TABLE CLASS="ECOS" WIDTH="98%" BORDER="0" ALIGN="LEFT" CELLPADDING="1">
<TR><TH COLSPAN="3" ALIGN="center">
<P CLASS="Gotos">DVP Assembler</P>
</TH></TR>
<TR><TD  ALIGN="center">
<P CLASS="Gotos">
<A HREF="ee-15.html">
To&nbsp;main&nbsp;page</A></P></TD>
<TD  ALIGN="center">
<P CLASS="Gotos">
<A HREF="ee-18.html">
To&nbsp;previous&nbsp;page</A></P></TD>
<TD  ALIGN="center">
<P CLASS="Gotos">
<A HREF="ee-20.html">
To&nbsp;next&nbsp;page</A></P></TD>
</TR></TABLE>
</BODY>
</HTML>
